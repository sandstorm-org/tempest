// Code generated by capnpc-go. DO NOT EDIT.

package spk

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	apisession "sandstorm.org/go/tempest/capnp/api-session"
	grain "sandstorm.org/go/tempest/capnp/grain"
	powerbox "sandstorm.org/go/tempest/capnp/powerbox"
	util "sandstorm.org/go/tempest/capnp/util"
	strconv "strconv"
)

const OsiInfo_ = uint64(0x9476412d0315d869)
const CategoryInfoAnnotation = uint64(0x8d51dd236606d205)

// Constants defined in package.capnp.
const (
	Manifest_sizeLimitInWords = uint64(1048576)
)

// Constants defined in package.capnp.
var (
	MagicNumber = []byte{143, 198, 205, 239, 69, 26, 234, 150}
)

type PackageDefinition capnp.Struct

// PackageDefinition_TypeID is the unique identifier for the type PackageDefinition.
const PackageDefinition_TypeID = 0x9f149fa71489be0b

func NewPackageDefinition(s *capnp.Segment) (PackageDefinition, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 6})
	return PackageDefinition(st), err
}

func NewRootPackageDefinition(s *capnp.Segment) (PackageDefinition, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 6})
	return PackageDefinition(st), err
}

func ReadRootPackageDefinition(msg *capnp.Message) (PackageDefinition, error) {
	root, err := msg.Root()
	return PackageDefinition(root.Struct()), err
}

func (s PackageDefinition) String() string {
	str, _ := text.Marshal(0x9f149fa71489be0b, capnp.Struct(s))
	return str
}

func (s PackageDefinition) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (PackageDefinition) DecodeFromPtr(p capnp.Ptr) PackageDefinition {
	return PackageDefinition(capnp.Struct{}.DecodeFromPtr(p))
}

func (s PackageDefinition) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s PackageDefinition) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s PackageDefinition) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s PackageDefinition) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s PackageDefinition) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s PackageDefinition) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s PackageDefinition) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s PackageDefinition) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s PackageDefinition) Manifest() (Manifest, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Manifest(p.Struct()), err
}

func (s PackageDefinition) HasManifest() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s PackageDefinition) SetManifest(v Manifest) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewManifest sets the manifest field to a newly
// allocated Manifest struct, preferring placement in s's segment.
func (s PackageDefinition) NewManifest() (Manifest, error) {
	ss, err := NewManifest(capnp.Struct(s).Segment())
	if err != nil {
		return Manifest{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s PackageDefinition) SourceMap() (SourceMap, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return SourceMap(p.Struct()), err
}

func (s PackageDefinition) HasSourceMap() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s PackageDefinition) SetSourceMap(v SourceMap) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewSourceMap sets the sourceMap field to a newly
// allocated SourceMap struct, preferring placement in s's segment.
func (s PackageDefinition) NewSourceMap() (SourceMap, error) {
	ss, err := NewSourceMap(capnp.Struct(s).Segment())
	if err != nil {
		return SourceMap{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s PackageDefinition) FileList() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s PackageDefinition) HasFileList() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s PackageDefinition) FileListBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s PackageDefinition) SetFileList(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s PackageDefinition) AlwaysInclude() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.TextList(p.List()), err
}

func (s PackageDefinition) HasAlwaysInclude() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s PackageDefinition) SetAlwaysInclude(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewAlwaysInclude sets the alwaysInclude field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s PackageDefinition) NewAlwaysInclude(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}
func (s PackageDefinition) BridgeConfig() (BridgeConfig, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return BridgeConfig(p.Struct()), err
}

func (s PackageDefinition) HasBridgeConfig() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s PackageDefinition) SetBridgeConfig(v BridgeConfig) error {
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewBridgeConfig sets the bridgeConfig field to a newly
// allocated BridgeConfig struct, preferring placement in s's segment.
func (s PackageDefinition) NewBridgeConfig() (BridgeConfig, error) {
	ss, err := NewBridgeConfig(capnp.Struct(s).Segment())
	if err != nil {
		return BridgeConfig{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

// PackageDefinition_List is a list of PackageDefinition.
type PackageDefinition_List = capnp.StructList[PackageDefinition]

// NewPackageDefinition creates a new list of PackageDefinition.
func NewPackageDefinition_List(s *capnp.Segment, sz int32) (PackageDefinition_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 6}, sz)
	return capnp.StructList[PackageDefinition](l), err
}

// PackageDefinition_Future is a wrapper for a PackageDefinition promised by a client call.
type PackageDefinition_Future struct{ *capnp.Future }

func (f PackageDefinition_Future) Struct() (PackageDefinition, error) {
	p, err := f.Future.Ptr()
	return PackageDefinition(p.Struct()), err
}
func (p PackageDefinition_Future) Manifest() Manifest_Future {
	return Manifest_Future{Future: p.Future.Field(1, nil)}
}
func (p PackageDefinition_Future) SourceMap() SourceMap_Future {
	return SourceMap_Future{Future: p.Future.Field(2, nil)}
}
func (p PackageDefinition_Future) BridgeConfig() BridgeConfig_Future {
	return BridgeConfig_Future{Future: p.Future.Field(5, nil)}
}

type Manifest capnp.Struct

// Manifest_TypeID is the unique identifier for the type Manifest.
const Manifest_TypeID = 0x855f296a69e6e1ca

func NewManifest(s *capnp.Segment) (Manifest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return Manifest(st), err
}

func NewRootManifest(s *capnp.Segment) (Manifest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return Manifest(st), err
}

func ReadRootManifest(msg *capnp.Message) (Manifest, error) {
	root, err := msg.Root()
	return Manifest(root.Struct()), err
}

func (s Manifest) String() string {
	str, _ := text.Marshal(0x855f296a69e6e1ca, capnp.Struct(s))
	return str
}

func (s Manifest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Manifest) DecodeFromPtr(p capnp.Ptr) Manifest {
	return Manifest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Manifest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Manifest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Manifest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Manifest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Manifest) AppTitle() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return util.LocalizedText(p.Struct()), err
}

func (s Manifest) HasAppTitle() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Manifest) SetAppTitle(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(3, capnp.Struct(v).ToPtr())
}

// NewAppTitle sets the appTitle field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Manifest) NewAppTitle() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(3, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Manifest) AppVersion() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s Manifest) SetAppVersion(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

func (s Manifest) MinUpgradableAppVersion() uint32 {
	return capnp.Struct(s).Uint32(12)
}

func (s Manifest) SetMinUpgradableAppVersion(v uint32) {
	capnp.Struct(s).SetUint32(12, v)
}

func (s Manifest) AppMarketingVersion() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return util.LocalizedText(p.Struct()), err
}

func (s Manifest) HasAppMarketingVersion() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Manifest) SetAppMarketingVersion(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewAppMarketingVersion sets the appMarketingVersion field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Manifest) NewAppMarketingVersion() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Manifest) MinApiVersion() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Manifest) SetMinApiVersion(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s Manifest) MaxApiVersion() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Manifest) SetMaxApiVersion(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

func (s Manifest) Metadata() (Metadata, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return Metadata(p.Struct()), err
}

func (s Manifest) HasMetadata() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Manifest) SetMetadata(v Metadata) error {
	return capnp.Struct(s).SetPtr(4, capnp.Struct(v).ToPtr())
}

// NewMetadata sets the metadata field to a newly
// allocated Metadata struct, preferring placement in s's segment.
func (s Manifest) NewMetadata() (Metadata, error) {
	ss, err := NewMetadata(capnp.Struct(s).Segment())
	if err != nil {
		return Metadata{}, err
	}
	err = capnp.Struct(s).SetPtr(4, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Manifest) Actions() (Manifest_Action_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Manifest_Action_List(p.List()), err
}

func (s Manifest) HasActions() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Manifest) SetActions(v Manifest_Action_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewActions sets the actions field to a newly
// allocated Manifest_Action_List, preferring placement in s's segment.
func (s Manifest) NewActions(n int32) (Manifest_Action_List, error) {
	l, err := NewManifest_Action_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Manifest_Action_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Manifest) ContinueCommand() (Manifest_Command, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Manifest_Command(p.Struct()), err
}

func (s Manifest) HasContinueCommand() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Manifest) SetContinueCommand(v Manifest_Command) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewContinueCommand sets the continueCommand field to a newly
// allocated Manifest_Command struct, preferring placement in s's segment.
func (s Manifest) NewContinueCommand() (Manifest_Command, error) {
	ss, err := NewManifest_Command(capnp.Struct(s).Segment())
	if err != nil {
		return Manifest_Command{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Manifest_List is a list of Manifest.
type Manifest_List = capnp.StructList[Manifest]

// NewManifest creates a new list of Manifest.
func NewManifest_List(s *capnp.Segment, sz int32) (Manifest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5}, sz)
	return capnp.StructList[Manifest](l), err
}

// Manifest_Future is a wrapper for a Manifest promised by a client call.
type Manifest_Future struct{ *capnp.Future }

func (f Manifest_Future) Struct() (Manifest, error) {
	p, err := f.Future.Ptr()
	return Manifest(p.Struct()), err
}
func (p Manifest_Future) AppTitle() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(3, nil)}
}
func (p Manifest_Future) AppMarketingVersion() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(2, nil)}
}
func (p Manifest_Future) Metadata() Metadata_Future {
	return Metadata_Future{Future: p.Future.Field(4, nil)}
}
func (p Manifest_Future) ContinueCommand() Manifest_Command_Future {
	return Manifest_Command_Future{Future: p.Future.Field(1, nil)}
}

type Manifest_Command capnp.Struct

// Manifest_Command_TypeID is the unique identifier for the type Manifest_Command.
const Manifest_Command_TypeID = 0xc64951b2a02886cf

func NewManifest_Command(s *capnp.Segment) (Manifest_Command, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Manifest_Command(st), err
}

func NewRootManifest_Command(s *capnp.Segment) (Manifest_Command, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Manifest_Command(st), err
}

func ReadRootManifest_Command(msg *capnp.Message) (Manifest_Command, error) {
	root, err := msg.Root()
	return Manifest_Command(root.Struct()), err
}

func (s Manifest_Command) String() string {
	str, _ := text.Marshal(0xc64951b2a02886cf, capnp.Struct(s))
	return str
}

func (s Manifest_Command) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Manifest_Command) DecodeFromPtr(p capnp.Ptr) Manifest_Command {
	return Manifest_Command(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Manifest_Command) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Manifest_Command) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Manifest_Command) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Manifest_Command) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Manifest_Command) Argv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s Manifest_Command) HasArgv() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Manifest_Command) SetArgv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewArgv sets the argv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Manifest_Command) NewArgv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Manifest_Command) Environ() (util.KeyValue_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return util.KeyValue_List(p.List()), err
}

func (s Manifest_Command) HasEnviron() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Manifest_Command) SetEnviron(v util.KeyValue_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewEnviron sets the environ field to a newly
// allocated util.KeyValue_List, preferring placement in s's segment.
func (s Manifest_Command) NewEnviron(n int32) (util.KeyValue_List, error) {
	l, err := util.NewKeyValue_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return util.KeyValue_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Manifest_Command) DeprecatedExecutablePath() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Manifest_Command) HasDeprecatedExecutablePath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Manifest_Command) DeprecatedExecutablePathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Manifest_Command) SetDeprecatedExecutablePath(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Manifest_Command_List is a list of Manifest_Command.
type Manifest_Command_List = capnp.StructList[Manifest_Command]

// NewManifest_Command creates a new list of Manifest_Command.
func NewManifest_Command_List(s *capnp.Segment, sz int32) (Manifest_Command_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[Manifest_Command](l), err
}

// Manifest_Command_Future is a wrapper for a Manifest_Command promised by a client call.
type Manifest_Command_Future struct{ *capnp.Future }

func (f Manifest_Command_Future) Struct() (Manifest_Command, error) {
	p, err := f.Future.Ptr()
	return Manifest_Command(p.Struct()), err
}

type Manifest_Action capnp.Struct
type Manifest_Action_input Manifest_Action
type Manifest_Action_input_Which uint16

const (
	Manifest_Action_input_Which_none       Manifest_Action_input_Which = 0
	Manifest_Action_input_Which_capability Manifest_Action_input_Which = 1
)

func (w Manifest_Action_input_Which) String() string {
	const s = "nonecapability"
	switch w {
	case Manifest_Action_input_Which_none:
		return s[0:4]
	case Manifest_Action_input_Which_capability:
		return s[4:14]

	}
	return "Manifest_Action_input_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Manifest_Action_TypeID is the unique identifier for the type Manifest_Action.
const Manifest_Action_TypeID = 0xe5c59b9296375a00

func NewManifest_Action(s *capnp.Segment) (Manifest_Action, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 5})
	return Manifest_Action(st), err
}

func NewRootManifest_Action(s *capnp.Segment) (Manifest_Action, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 5})
	return Manifest_Action(st), err
}

func ReadRootManifest_Action(msg *capnp.Message) (Manifest_Action, error) {
	root, err := msg.Root()
	return Manifest_Action(root.Struct()), err
}

func (s Manifest_Action) String() string {
	str, _ := text.Marshal(0xe5c59b9296375a00, capnp.Struct(s))
	return str
}

func (s Manifest_Action) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Manifest_Action) DecodeFromPtr(p capnp.Ptr) Manifest_Action {
	return Manifest_Action(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Manifest_Action) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Manifest_Action) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Manifest_Action) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Manifest_Action) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Manifest_Action) Input() Manifest_Action_input { return Manifest_Action_input(s) }

func (s Manifest_Action_input) Which() Manifest_Action_input_Which {
	return Manifest_Action_input_Which(capnp.Struct(s).Uint16(0))
}
func (s Manifest_Action_input) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Manifest_Action_input) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Manifest_Action_input) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Manifest_Action_input) SetNone() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Manifest_Action_input) Capability() (powerbox.PowerboxDescriptor_List, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != capability")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return powerbox.PowerboxDescriptor_List(p.List()), err
}

func (s Manifest_Action_input) HasCapability() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Manifest_Action_input) SetCapability(v powerbox.PowerboxDescriptor_List) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewCapability sets the capability field to a newly
// allocated powerbox.PowerboxDescriptor_List, preferring placement in s's segment.
func (s Manifest_Action_input) NewCapability(n int32) (powerbox.PowerboxDescriptor_List, error) {
	capnp.Struct(s).SetUint16(0, 1)
	l, err := powerbox.NewPowerboxDescriptor_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return powerbox.PowerboxDescriptor_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Manifest_Action) Command() (Manifest_Command, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Manifest_Command(p.Struct()), err
}

func (s Manifest_Action) HasCommand() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Manifest_Action) SetCommand(v Manifest_Command) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewCommand sets the command field to a newly
// allocated Manifest_Command struct, preferring placement in s's segment.
func (s Manifest_Action) NewCommand() (Manifest_Command, error) {
	ss, err := NewManifest_Command(capnp.Struct(s).Segment())
	if err != nil {
		return Manifest_Command{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Manifest_Action) Title() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return util.LocalizedText(p.Struct()), err
}

func (s Manifest_Action) HasTitle() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Manifest_Action) SetTitle(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewTitle sets the title field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Manifest_Action) NewTitle() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Manifest_Action) NounPhrase() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(4)
	if err != nil {
		return util.LocalizedText{}, err
	}
	ss, err := p.StructDefault(x_df9bc20172856a3a[0:40])
	return util.LocalizedText(ss), err
}

func (s Manifest_Action) HasNounPhrase() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Manifest_Action) SetNounPhrase(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(4, capnp.Struct(v).ToPtr())
}

// NewNounPhrase sets the nounPhrase field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Manifest_Action) NewNounPhrase() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(4, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Manifest_Action) Description() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return util.LocalizedText(p.Struct()), err
}

func (s Manifest_Action) HasDescription() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Manifest_Action) SetDescription(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(3, capnp.Struct(v).ToPtr())
}

// NewDescription sets the description field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Manifest_Action) NewDescription() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(3, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Manifest_Action_List is a list of Manifest_Action.
type Manifest_Action_List = capnp.StructList[Manifest_Action]

// NewManifest_Action creates a new list of Manifest_Action.
func NewManifest_Action_List(s *capnp.Segment, sz int32) (Manifest_Action_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 5}, sz)
	return capnp.StructList[Manifest_Action](l), err
}

// Manifest_Action_Future is a wrapper for a Manifest_Action promised by a client call.
type Manifest_Action_Future struct{ *capnp.Future }

func (f Manifest_Action_Future) Struct() (Manifest_Action, error) {
	p, err := f.Future.Ptr()
	return Manifest_Action(p.Struct()), err
}
func (p Manifest_Action_Future) Input() Manifest_Action_input_Future {
	return Manifest_Action_input_Future{p.Future}
}

// Manifest_Action_input_Future is a wrapper for a Manifest_Action_input promised by a client call.
type Manifest_Action_input_Future struct{ *capnp.Future }

func (f Manifest_Action_input_Future) Struct() (Manifest_Action_input, error) {
	p, err := f.Future.Ptr()
	return Manifest_Action_input(p.Struct()), err
}
func (p Manifest_Action_Future) Command() Manifest_Command_Future {
	return Manifest_Command_Future{Future: p.Future.Field(1, nil)}
}
func (p Manifest_Action_Future) Title() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(2, nil)}
}
func (p Manifest_Action_Future) NounPhrase() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(4, x_df9bc20172856a3a[40:80])}
}
func (p Manifest_Action_Future) Description() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(3, nil)}
}

type SourceMap capnp.Struct

// SourceMap_TypeID is the unique identifier for the type SourceMap.
const SourceMap_TypeID = 0xe3d7ba482b2e470b

func NewSourceMap(s *capnp.Segment) (SourceMap, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SourceMap(st), err
}

func NewRootSourceMap(s *capnp.Segment) (SourceMap, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SourceMap(st), err
}

func ReadRootSourceMap(msg *capnp.Message) (SourceMap, error) {
	root, err := msg.Root()
	return SourceMap(root.Struct()), err
}

func (s SourceMap) String() string {
	str, _ := text.Marshal(0xe3d7ba482b2e470b, capnp.Struct(s))
	return str
}

func (s SourceMap) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SourceMap) DecodeFromPtr(p capnp.Ptr) SourceMap {
	return SourceMap(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SourceMap) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SourceMap) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SourceMap) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SourceMap) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SourceMap) SearchPath() (SourceMap_Mapping_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SourceMap_Mapping_List(p.List()), err
}

func (s SourceMap) HasSearchPath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SourceMap) SetSearchPath(v SourceMap_Mapping_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewSearchPath sets the searchPath field to a newly
// allocated SourceMap_Mapping_List, preferring placement in s's segment.
func (s SourceMap) NewSearchPath(n int32) (SourceMap_Mapping_List, error) {
	l, err := NewSourceMap_Mapping_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return SourceMap_Mapping_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// SourceMap_List is a list of SourceMap.
type SourceMap_List = capnp.StructList[SourceMap]

// NewSourceMap creates a new list of SourceMap.
func NewSourceMap_List(s *capnp.Segment, sz int32) (SourceMap_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[SourceMap](l), err
}

// SourceMap_Future is a wrapper for a SourceMap promised by a client call.
type SourceMap_Future struct{ *capnp.Future }

func (f SourceMap_Future) Struct() (SourceMap, error) {
	p, err := f.Future.Ptr()
	return SourceMap(p.Struct()), err
}

type SourceMap_Mapping capnp.Struct

// SourceMap_Mapping_TypeID is the unique identifier for the type SourceMap_Mapping.
const SourceMap_Mapping_TypeID = 0x87dcf1b1edcb3eaf

func NewSourceMap_Mapping(s *capnp.Segment) (SourceMap_Mapping, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return SourceMap_Mapping(st), err
}

func NewRootSourceMap_Mapping(s *capnp.Segment) (SourceMap_Mapping, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return SourceMap_Mapping(st), err
}

func ReadRootSourceMap_Mapping(msg *capnp.Message) (SourceMap_Mapping, error) {
	root, err := msg.Root()
	return SourceMap_Mapping(root.Struct()), err
}

func (s SourceMap_Mapping) String() string {
	str, _ := text.Marshal(0x87dcf1b1edcb3eaf, capnp.Struct(s))
	return str
}

func (s SourceMap_Mapping) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SourceMap_Mapping) DecodeFromPtr(p capnp.Ptr) SourceMap_Mapping {
	return SourceMap_Mapping(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SourceMap_Mapping) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SourceMap_Mapping) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SourceMap_Mapping) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SourceMap_Mapping) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SourceMap_Mapping) PackagePath() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s SourceMap_Mapping) HasPackagePath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SourceMap_Mapping) PackagePathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s SourceMap_Mapping) SetPackagePath(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s SourceMap_Mapping) SourcePath() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s SourceMap_Mapping) HasSourcePath() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s SourceMap_Mapping) SourcePathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s SourceMap_Mapping) SetSourcePath(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s SourceMap_Mapping) HidePaths() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.TextList(p.List()), err
}

func (s SourceMap_Mapping) HasHidePaths() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s SourceMap_Mapping) SetHidePaths(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewHidePaths sets the hidePaths field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s SourceMap_Mapping) NewHidePaths(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// SourceMap_Mapping_List is a list of SourceMap_Mapping.
type SourceMap_Mapping_List = capnp.StructList[SourceMap_Mapping]

// NewSourceMap_Mapping creates a new list of SourceMap_Mapping.
func NewSourceMap_Mapping_List(s *capnp.Segment, sz int32) (SourceMap_Mapping_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[SourceMap_Mapping](l), err
}

// SourceMap_Mapping_Future is a wrapper for a SourceMap_Mapping promised by a client call.
type SourceMap_Mapping_Future struct{ *capnp.Future }

func (f SourceMap_Mapping_Future) Struct() (SourceMap_Mapping, error) {
	p, err := f.Future.Ptr()
	return SourceMap_Mapping(p.Struct()), err
}

type BridgeConfig capnp.Struct

// BridgeConfig_TypeID is the unique identifier for the type BridgeConfig.
const BridgeConfig_TypeID = 0xdd8c82383168c096

func NewBridgeConfig(s *capnp.Segment) (BridgeConfig, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return BridgeConfig(st), err
}

func NewRootBridgeConfig(s *capnp.Segment) (BridgeConfig, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return BridgeConfig(st), err
}

func ReadRootBridgeConfig(msg *capnp.Message) (BridgeConfig, error) {
	root, err := msg.Root()
	return BridgeConfig(root.Struct()), err
}

func (s BridgeConfig) String() string {
	str, _ := text.Marshal(0xdd8c82383168c096, capnp.Struct(s))
	return str
}

func (s BridgeConfig) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (BridgeConfig) DecodeFromPtr(p capnp.Ptr) BridgeConfig {
	return BridgeConfig(capnp.Struct{}.DecodeFromPtr(p))
}

func (s BridgeConfig) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s BridgeConfig) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s BridgeConfig) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s BridgeConfig) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s BridgeConfig) ViewInfo() (grain.UiView_ViewInfo, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return grain.UiView_ViewInfo(p.Struct()), err
}

func (s BridgeConfig) HasViewInfo() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s BridgeConfig) SetViewInfo(v grain.UiView_ViewInfo) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewViewInfo sets the viewInfo field to a newly
// allocated grain.UiView_ViewInfo struct, preferring placement in s's segment.
func (s BridgeConfig) NewViewInfo() (grain.UiView_ViewInfo, error) {
	ss, err := grain.NewUiView_ViewInfo(capnp.Struct(s).Segment())
	if err != nil {
		return grain.UiView_ViewInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s BridgeConfig) ApiPath() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s BridgeConfig) HasApiPath() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s BridgeConfig) ApiPathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s BridgeConfig) SetApiPath(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s BridgeConfig) SaveIdentityCaps() bool {
	return capnp.Struct(s).Bit(0)
}

func (s BridgeConfig) SetSaveIdentityCaps(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

func (s BridgeConfig) ExpectAppHooks() bool {
	return capnp.Struct(s).Bit(1)
}

func (s BridgeConfig) SetExpectAppHooks(v bool) {
	capnp.Struct(s).SetBit(1, v)
}

func (s BridgeConfig) PowerboxApis() (BridgeConfig_PowerboxApi_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return BridgeConfig_PowerboxApi_List(p.List()), err
}

func (s BridgeConfig) HasPowerboxApis() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s BridgeConfig) SetPowerboxApis(v BridgeConfig_PowerboxApi_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewPowerboxApis sets the powerboxApis field to a newly
// allocated BridgeConfig_PowerboxApi_List, preferring placement in s's segment.
func (s BridgeConfig) NewPowerboxApis(n int32) (BridgeConfig_PowerboxApi_List, error) {
	l, err := NewBridgeConfig_PowerboxApi_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return BridgeConfig_PowerboxApi_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// BridgeConfig_List is a list of BridgeConfig.
type BridgeConfig_List = capnp.StructList[BridgeConfig]

// NewBridgeConfig creates a new list of BridgeConfig.
func NewBridgeConfig_List(s *capnp.Segment, sz int32) (BridgeConfig_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3}, sz)
	return capnp.StructList[BridgeConfig](l), err
}

// BridgeConfig_Future is a wrapper for a BridgeConfig promised by a client call.
type BridgeConfig_Future struct{ *capnp.Future }

func (f BridgeConfig_Future) Struct() (BridgeConfig, error) {
	p, err := f.Future.Ptr()
	return BridgeConfig(p.Struct()), err
}
func (p BridgeConfig_Future) ViewInfo() grain.UiView_ViewInfo_Future {
	return grain.UiView_ViewInfo_Future{Future: p.Future.Field(0, nil)}
}

type BridgeConfig_PowerboxApi capnp.Struct

// BridgeConfig_PowerboxApi_TypeID is the unique identifier for the type BridgeConfig_PowerboxApi.
const BridgeConfig_PowerboxApi_TypeID = 0xc9702c7dbfc6d7e4

func NewBridgeConfig_PowerboxApi(s *capnp.Segment) (BridgeConfig_PowerboxApi, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return BridgeConfig_PowerboxApi(st), err
}

func NewRootBridgeConfig_PowerboxApi(s *capnp.Segment) (BridgeConfig_PowerboxApi, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return BridgeConfig_PowerboxApi(st), err
}

func ReadRootBridgeConfig_PowerboxApi(msg *capnp.Message) (BridgeConfig_PowerboxApi, error) {
	root, err := msg.Root()
	return BridgeConfig_PowerboxApi(root.Struct()), err
}

func (s BridgeConfig_PowerboxApi) String() string {
	str, _ := text.Marshal(0xc9702c7dbfc6d7e4, capnp.Struct(s))
	return str
}

func (s BridgeConfig_PowerboxApi) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (BridgeConfig_PowerboxApi) DecodeFromPtr(p capnp.Ptr) BridgeConfig_PowerboxApi {
	return BridgeConfig_PowerboxApi(capnp.Struct{}.DecodeFromPtr(p))
}

func (s BridgeConfig_PowerboxApi) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s BridgeConfig_PowerboxApi) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s BridgeConfig_PowerboxApi) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s BridgeConfig_PowerboxApi) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s BridgeConfig_PowerboxApi) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s BridgeConfig_PowerboxApi) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s BridgeConfig_PowerboxApi) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s BridgeConfig_PowerboxApi) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s BridgeConfig_PowerboxApi) DisplayInfo() (powerbox.PowerboxDisplayInfo, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return powerbox.PowerboxDisplayInfo(p.Struct()), err
}

func (s BridgeConfig_PowerboxApi) HasDisplayInfo() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s BridgeConfig_PowerboxApi) SetDisplayInfo(v powerbox.PowerboxDisplayInfo) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewDisplayInfo sets the displayInfo field to a newly
// allocated powerbox.PowerboxDisplayInfo struct, preferring placement in s's segment.
func (s BridgeConfig_PowerboxApi) NewDisplayInfo() (powerbox.PowerboxDisplayInfo, error) {
	ss, err := powerbox.NewPowerboxDisplayInfo(capnp.Struct(s).Segment())
	if err != nil {
		return powerbox.PowerboxDisplayInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s BridgeConfig_PowerboxApi) Path() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s BridgeConfig_PowerboxApi) HasPath() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s BridgeConfig_PowerboxApi) PathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s BridgeConfig_PowerboxApi) SetPath(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s BridgeConfig_PowerboxApi) Tag() (apisession.ApiSession_PowerboxTag, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return apisession.ApiSession_PowerboxTag(p.Struct()), err
}

func (s BridgeConfig_PowerboxApi) HasTag() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s BridgeConfig_PowerboxApi) SetTag(v apisession.ApiSession_PowerboxTag) error {
	return capnp.Struct(s).SetPtr(3, capnp.Struct(v).ToPtr())
}

// NewTag sets the tag field to a newly
// allocated apisession.ApiSession_PowerboxTag struct, preferring placement in s's segment.
func (s BridgeConfig_PowerboxApi) NewTag() (apisession.ApiSession_PowerboxTag, error) {
	ss, err := apisession.NewApiSession_PowerboxTag(capnp.Struct(s).Segment())
	if err != nil {
		return apisession.ApiSession_PowerboxTag{}, err
	}
	err = capnp.Struct(s).SetPtr(3, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s BridgeConfig_PowerboxApi) Permissions() (capnp.BitList, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.BitList(p.List()), err
}

func (s BridgeConfig_PowerboxApi) HasPermissions() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s BridgeConfig_PowerboxApi) SetPermissions(v capnp.BitList) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewPermissions sets the permissions field to a newly
// allocated capnp.BitList, preferring placement in s's segment.
func (s BridgeConfig_PowerboxApi) NewPermissions(n int32) (capnp.BitList, error) {
	l, err := capnp.NewBitList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.BitList{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}

// BridgeConfig_PowerboxApi_List is a list of BridgeConfig_PowerboxApi.
type BridgeConfig_PowerboxApi_List = capnp.StructList[BridgeConfig_PowerboxApi]

// NewBridgeConfig_PowerboxApi creates a new list of BridgeConfig_PowerboxApi.
func NewBridgeConfig_PowerboxApi_List(s *capnp.Segment, sz int32) (BridgeConfig_PowerboxApi_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5}, sz)
	return capnp.StructList[BridgeConfig_PowerboxApi](l), err
}

// BridgeConfig_PowerboxApi_Future is a wrapper for a BridgeConfig_PowerboxApi promised by a client call.
type BridgeConfig_PowerboxApi_Future struct{ *capnp.Future }

func (f BridgeConfig_PowerboxApi_Future) Struct() (BridgeConfig_PowerboxApi, error) {
	p, err := f.Future.Ptr()
	return BridgeConfig_PowerboxApi(p.Struct()), err
}
func (p BridgeConfig_PowerboxApi_Future) DisplayInfo() powerbox.PowerboxDisplayInfo_Future {
	return powerbox.PowerboxDisplayInfo_Future{Future: p.Future.Field(1, nil)}
}
func (p BridgeConfig_PowerboxApi_Future) Tag() apisession.ApiSession_PowerboxTag_Future {
	return apisession.ApiSession_PowerboxTag_Future{Future: p.Future.Field(3, nil)}
}

type Metadata capnp.Struct
type Metadata_icons Metadata
type Metadata_license Metadata
type Metadata_author Metadata
type Metadata_license_Which uint16

const (
	Metadata_license_Which_none         Metadata_license_Which = 0
	Metadata_license_Which_openSource   Metadata_license_Which = 1
	Metadata_license_Which_proprietary  Metadata_license_Which = 2
	Metadata_license_Which_publicDomain Metadata_license_Which = 3
)

func (w Metadata_license_Which) String() string {
	const s = "noneopenSourceproprietarypublicDomain"
	switch w {
	case Metadata_license_Which_none:
		return s[0:4]
	case Metadata_license_Which_openSource:
		return s[4:14]
	case Metadata_license_Which_proprietary:
		return s[14:25]
	case Metadata_license_Which_publicDomain:
		return s[25:37]

	}
	return "Metadata_license_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Metadata_TypeID is the unique identifier for the type Metadata.
const Metadata_TypeID = 0xe0c5892a5448f4ee

func NewMetadata(s *capnp.Segment) (Metadata, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 17})
	return Metadata(st), err
}

func NewRootMetadata(s *capnp.Segment) (Metadata, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 17})
	return Metadata(st), err
}

func ReadRootMetadata(msg *capnp.Message) (Metadata, error) {
	root, err := msg.Root()
	return Metadata(root.Struct()), err
}

func (s Metadata) String() string {
	str, _ := text.Marshal(0xe0c5892a5448f4ee, capnp.Struct(s))
	return str
}

func (s Metadata) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Metadata) DecodeFromPtr(p capnp.Ptr) Metadata {
	return Metadata(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Metadata) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Metadata) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Metadata) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Metadata) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Metadata) Icons() Metadata_icons { return Metadata_icons(s) }

func (s Metadata_icons) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Metadata_icons) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Metadata_icons) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Metadata_icons) AppGrid() (Metadata_Icon, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Metadata_Icon(p.Struct()), err
}

func (s Metadata_icons) HasAppGrid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Metadata_icons) SetAppGrid(v Metadata_Icon) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewAppGrid sets the appGrid field to a newly
// allocated Metadata_Icon struct, preferring placement in s's segment.
func (s Metadata_icons) NewAppGrid() (Metadata_Icon, error) {
	ss, err := NewMetadata_Icon(capnp.Struct(s).Segment())
	if err != nil {
		return Metadata_Icon{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Metadata_icons) Grain() (Metadata_Icon, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Metadata_Icon(p.Struct()), err
}

func (s Metadata_icons) HasGrain() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Metadata_icons) SetGrain(v Metadata_Icon) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewGrain sets the grain field to a newly
// allocated Metadata_Icon struct, preferring placement in s's segment.
func (s Metadata_icons) NewGrain() (Metadata_Icon, error) {
	ss, err := NewMetadata_Icon(capnp.Struct(s).Segment())
	if err != nil {
		return Metadata_Icon{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Metadata_icons) Market() (Metadata_Icon, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Metadata_Icon(p.Struct()), err
}

func (s Metadata_icons) HasMarket() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Metadata_icons) SetMarket(v Metadata_Icon) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewMarket sets the market field to a newly
// allocated Metadata_Icon struct, preferring placement in s's segment.
func (s Metadata_icons) NewMarket() (Metadata_Icon, error) {
	ss, err := NewMetadata_Icon(capnp.Struct(s).Segment())
	if err != nil {
		return Metadata_Icon{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Metadata_icons) MarketBig() (Metadata_Icon, error) {
	p, err := capnp.Struct(s).Ptr(15)
	return Metadata_Icon(p.Struct()), err
}

func (s Metadata_icons) HasMarketBig() bool {
	return capnp.Struct(s).HasPtr(15)
}

func (s Metadata_icons) SetMarketBig(v Metadata_Icon) error {
	return capnp.Struct(s).SetPtr(15, capnp.Struct(v).ToPtr())
}

// NewMarketBig sets the marketBig field to a newly
// allocated Metadata_Icon struct, preferring placement in s's segment.
func (s Metadata_icons) NewMarketBig() (Metadata_Icon, error) {
	ss, err := NewMetadata_Icon(capnp.Struct(s).Segment())
	if err != nil {
		return Metadata_Icon{}, err
	}
	err = capnp.Struct(s).SetPtr(15, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Metadata) Website() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Metadata) HasWebsite() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Metadata) WebsiteBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Metadata) SetWebsite(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Metadata) CodeUrl() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s Metadata) HasCodeUrl() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Metadata) CodeUrlBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s Metadata) SetCodeUrl(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s Metadata) License() Metadata_license { return Metadata_license(s) }

func (s Metadata_license) Which() Metadata_license_Which {
	return Metadata_license_Which(capnp.Struct(s).Uint16(0))
}
func (s Metadata_license) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Metadata_license) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Metadata_license) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Metadata_license) SetNone() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Metadata_license) OpenSource() OpenSourceLicense {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != openSource")
	}
	return OpenSourceLicense(capnp.Struct(s).Uint16(2))
}

func (s Metadata_license) SetOpenSource(v OpenSourceLicense) {
	capnp.Struct(s).SetUint16(0, 1)
	capnp.Struct(s).SetUint16(2, uint16(v))
}

func (s Metadata_license) Proprietary() (util.LocalizedText, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != proprietary")
	}
	p, err := capnp.Struct(s).Ptr(5)
	return util.LocalizedText(p.Struct()), err
}

func (s Metadata_license) HasProprietary() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(5)
}

func (s Metadata_license) SetProprietary(v util.LocalizedText) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewProprietary sets the proprietary field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Metadata_license) NewProprietary() (util.LocalizedText, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Metadata_license) PublicDomain() (util.LocalizedText, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != publicDomain")
	}
	p, err := capnp.Struct(s).Ptr(5)
	return util.LocalizedText(p.Struct()), err
}

func (s Metadata_license) HasPublicDomain() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(5)
}

func (s Metadata_license) SetPublicDomain(v util.LocalizedText) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewPublicDomain sets the publicDomain field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Metadata_license) NewPublicDomain() (util.LocalizedText, error) {
	capnp.Struct(s).SetUint16(0, 3)
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Metadata_license) Notices() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return util.LocalizedText(p.Struct()), err
}

func (s Metadata_license) HasNotices() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Metadata_license) SetNotices(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(6, capnp.Struct(v).ToPtr())
}

// NewNotices sets the notices field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Metadata_license) NewNotices() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(6, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Metadata) Categories() (Category_List, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return Category_List(p.List()), err
}

func (s Metadata) HasCategories() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s Metadata) SetCategories(v Category_List) error {
	return capnp.Struct(s).SetPtr(7, v.ToPtr())
}

// NewCategories sets the categories field to a newly
// allocated Category_List, preferring placement in s's segment.
func (s Metadata) NewCategories(n int32) (Category_List, error) {
	l, err := NewCategory_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Category_List{}, err
	}
	err = capnp.Struct(s).SetPtr(7, l.ToPtr())
	return l, err
}
func (s Metadata) Author() Metadata_author { return Metadata_author(s) }

func (s Metadata_author) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Metadata_author) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Metadata_author) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Metadata_author) UpstreamAuthor() (string, error) {
	p, err := capnp.Struct(s).Ptr(16)
	return p.Text(), err
}

func (s Metadata_author) HasUpstreamAuthor() bool {
	return capnp.Struct(s).HasPtr(16)
}

func (s Metadata_author) UpstreamAuthorBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(16)
	return p.TextBytes(), err
}

func (s Metadata_author) SetUpstreamAuthor(v string) error {
	return capnp.Struct(s).SetText(16, v)
}

func (s Metadata_author) ContactEmail() (string, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return p.Text(), err
}

func (s Metadata_author) HasContactEmail() bool {
	return capnp.Struct(s).HasPtr(8)
}

func (s Metadata_author) ContactEmailBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return p.TextBytes(), err
}

func (s Metadata_author) SetContactEmail(v string) error {
	return capnp.Struct(s).SetText(8, v)
}

func (s Metadata_author) PgpSignature() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(9)
	return []byte(p.Data()), err
}

func (s Metadata_author) HasPgpSignature() bool {
	return capnp.Struct(s).HasPtr(9)
}

func (s Metadata_author) SetPgpSignature(v []byte) error {
	return capnp.Struct(s).SetData(9, v)
}

func (s Metadata) PgpKeyring() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(10)
	return []byte(p.Data()), err
}

func (s Metadata) HasPgpKeyring() bool {
	return capnp.Struct(s).HasPtr(10)
}

func (s Metadata) SetPgpKeyring(v []byte) error {
	return capnp.Struct(s).SetData(10, v)
}

func (s Metadata) Description() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(11)
	return util.LocalizedText(p.Struct()), err
}

func (s Metadata) HasDescription() bool {
	return capnp.Struct(s).HasPtr(11)
}

func (s Metadata) SetDescription(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(11, capnp.Struct(v).ToPtr())
}

// NewDescription sets the description field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Metadata) NewDescription() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(11, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Metadata) ShortDescription() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(12)
	return util.LocalizedText(p.Struct()), err
}

func (s Metadata) HasShortDescription() bool {
	return capnp.Struct(s).HasPtr(12)
}

func (s Metadata) SetShortDescription(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(12, capnp.Struct(v).ToPtr())
}

// NewShortDescription sets the shortDescription field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Metadata) NewShortDescription() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(12, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Metadata) Screenshots() (Metadata_Screenshot_List, error) {
	p, err := capnp.Struct(s).Ptr(13)
	return Metadata_Screenshot_List(p.List()), err
}

func (s Metadata) HasScreenshots() bool {
	return capnp.Struct(s).HasPtr(13)
}

func (s Metadata) SetScreenshots(v Metadata_Screenshot_List) error {
	return capnp.Struct(s).SetPtr(13, v.ToPtr())
}

// NewScreenshots sets the screenshots field to a newly
// allocated Metadata_Screenshot_List, preferring placement in s's segment.
func (s Metadata) NewScreenshots(n int32) (Metadata_Screenshot_List, error) {
	l, err := NewMetadata_Screenshot_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Metadata_Screenshot_List{}, err
	}
	err = capnp.Struct(s).SetPtr(13, l.ToPtr())
	return l, err
}
func (s Metadata) ChangeLog() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(14)
	return util.LocalizedText(p.Struct()), err
}

func (s Metadata) HasChangeLog() bool {
	return capnp.Struct(s).HasPtr(14)
}

func (s Metadata) SetChangeLog(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(14, capnp.Struct(v).ToPtr())
}

// NewChangeLog sets the changeLog field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s Metadata) NewChangeLog() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(14, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Metadata_List is a list of Metadata.
type Metadata_List = capnp.StructList[Metadata]

// NewMetadata creates a new list of Metadata.
func NewMetadata_List(s *capnp.Segment, sz int32) (Metadata_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 17}, sz)
	return capnp.StructList[Metadata](l), err
}

// Metadata_Future is a wrapper for a Metadata promised by a client call.
type Metadata_Future struct{ *capnp.Future }

func (f Metadata_Future) Struct() (Metadata, error) {
	p, err := f.Future.Ptr()
	return Metadata(p.Struct()), err
}
func (p Metadata_Future) Icons() Metadata_icons_Future { return Metadata_icons_Future{p.Future} }

// Metadata_icons_Future is a wrapper for a Metadata_icons promised by a client call.
type Metadata_icons_Future struct{ *capnp.Future }

func (f Metadata_icons_Future) Struct() (Metadata_icons, error) {
	p, err := f.Future.Ptr()
	return Metadata_icons(p.Struct()), err
}
func (p Metadata_icons_Future) AppGrid() Metadata_Icon_Future {
	return Metadata_Icon_Future{Future: p.Future.Field(0, nil)}
}
func (p Metadata_icons_Future) Grain() Metadata_Icon_Future {
	return Metadata_Icon_Future{Future: p.Future.Field(1, nil)}
}
func (p Metadata_icons_Future) Market() Metadata_Icon_Future {
	return Metadata_Icon_Future{Future: p.Future.Field(2, nil)}
}
func (p Metadata_icons_Future) MarketBig() Metadata_Icon_Future {
	return Metadata_Icon_Future{Future: p.Future.Field(15, nil)}
}
func (p Metadata_Future) License() Metadata_license_Future { return Metadata_license_Future{p.Future} }

// Metadata_license_Future is a wrapper for a Metadata_license promised by a client call.
type Metadata_license_Future struct{ *capnp.Future }

func (f Metadata_license_Future) Struct() (Metadata_license, error) {
	p, err := f.Future.Ptr()
	return Metadata_license(p.Struct()), err
}
func (p Metadata_license_Future) Proprietary() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(5, nil)}
}
func (p Metadata_license_Future) PublicDomain() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(5, nil)}
}
func (p Metadata_license_Future) Notices() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(6, nil)}
}
func (p Metadata_Future) Author() Metadata_author_Future { return Metadata_author_Future{p.Future} }

// Metadata_author_Future is a wrapper for a Metadata_author promised by a client call.
type Metadata_author_Future struct{ *capnp.Future }

func (f Metadata_author_Future) Struct() (Metadata_author, error) {
	p, err := f.Future.Ptr()
	return Metadata_author(p.Struct()), err
}
func (p Metadata_Future) Description() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(11, nil)}
}
func (p Metadata_Future) ShortDescription() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(12, nil)}
}
func (p Metadata_Future) ChangeLog() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(14, nil)}
}

type Metadata_Icon capnp.Struct
type Metadata_Icon_png Metadata_Icon
type Metadata_Icon_Which uint16

const (
	Metadata_Icon_Which_unknown Metadata_Icon_Which = 0
	Metadata_Icon_Which_svg     Metadata_Icon_Which = 1
	Metadata_Icon_Which_png     Metadata_Icon_Which = 2
)

func (w Metadata_Icon_Which) String() string {
	const s = "unknownsvgpng"
	switch w {
	case Metadata_Icon_Which_unknown:
		return s[0:7]
	case Metadata_Icon_Which_svg:
		return s[7:10]
	case Metadata_Icon_Which_png:
		return s[10:13]

	}
	return "Metadata_Icon_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Metadata_Icon_TypeID is the unique identifier for the type Metadata_Icon.
const Metadata_Icon_TypeID = 0xe492a2981208ad0b

func NewMetadata_Icon(s *capnp.Segment) (Metadata_Icon, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Metadata_Icon(st), err
}

func NewRootMetadata_Icon(s *capnp.Segment) (Metadata_Icon, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Metadata_Icon(st), err
}

func ReadRootMetadata_Icon(msg *capnp.Message) (Metadata_Icon, error) {
	root, err := msg.Root()
	return Metadata_Icon(root.Struct()), err
}

func (s Metadata_Icon) String() string {
	str, _ := text.Marshal(0xe492a2981208ad0b, capnp.Struct(s))
	return str
}

func (s Metadata_Icon) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Metadata_Icon) DecodeFromPtr(p capnp.Ptr) Metadata_Icon {
	return Metadata_Icon(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Metadata_Icon) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Metadata_Icon) Which() Metadata_Icon_Which {
	return Metadata_Icon_Which(capnp.Struct(s).Uint16(0))
}
func (s Metadata_Icon) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Metadata_Icon) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Metadata_Icon) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Metadata_Icon) SetUnknown() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Metadata_Icon) Svg() (string, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != svg")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Metadata_Icon) HasSvg() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Metadata_Icon) SvgBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Metadata_Icon) SetSvg(v string) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetText(0, v)
}

func (s Metadata_Icon) Png() Metadata_Icon_png { return Metadata_Icon_png(s) }

func (s Metadata_Icon) SetPng() {
	capnp.Struct(s).SetUint16(0, 2)
}

func (s Metadata_Icon_png) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Metadata_Icon_png) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Metadata_Icon_png) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Metadata_Icon_png) Dpi1x() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Metadata_Icon_png) HasDpi1x() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Metadata_Icon_png) SetDpi1x(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Metadata_Icon_png) Dpi2x() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Metadata_Icon_png) HasDpi2x() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Metadata_Icon_png) SetDpi2x(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// Metadata_Icon_List is a list of Metadata_Icon.
type Metadata_Icon_List = capnp.StructList[Metadata_Icon]

// NewMetadata_Icon creates a new list of Metadata_Icon.
func NewMetadata_Icon_List(s *capnp.Segment, sz int32) (Metadata_Icon_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Metadata_Icon](l), err
}

// Metadata_Icon_Future is a wrapper for a Metadata_Icon promised by a client call.
type Metadata_Icon_Future struct{ *capnp.Future }

func (f Metadata_Icon_Future) Struct() (Metadata_Icon, error) {
	p, err := f.Future.Ptr()
	return Metadata_Icon(p.Struct()), err
}
func (p Metadata_Icon_Future) Png() Metadata_Icon_png_Future {
	return Metadata_Icon_png_Future{p.Future}
}

// Metadata_Icon_png_Future is a wrapper for a Metadata_Icon_png promised by a client call.
type Metadata_Icon_png_Future struct{ *capnp.Future }

func (f Metadata_Icon_png_Future) Struct() (Metadata_Icon_png, error) {
	p, err := f.Future.Ptr()
	return Metadata_Icon_png(p.Struct()), err
}

type Metadata_Screenshot capnp.Struct
type Metadata_Screenshot_Which uint16

const (
	Metadata_Screenshot_Which_unknown Metadata_Screenshot_Which = 0
	Metadata_Screenshot_Which_png     Metadata_Screenshot_Which = 1
	Metadata_Screenshot_Which_jpeg    Metadata_Screenshot_Which = 2
)

func (w Metadata_Screenshot_Which) String() string {
	const s = "unknownpngjpeg"
	switch w {
	case Metadata_Screenshot_Which_unknown:
		return s[0:7]
	case Metadata_Screenshot_Which_png:
		return s[7:10]
	case Metadata_Screenshot_Which_jpeg:
		return s[10:14]

	}
	return "Metadata_Screenshot_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Metadata_Screenshot_TypeID is the unique identifier for the type Metadata_Screenshot.
const Metadata_Screenshot_TypeID = 0x8bc9f4365959348e

func NewMetadata_Screenshot(s *capnp.Segment) (Metadata_Screenshot, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Metadata_Screenshot(st), err
}

func NewRootMetadata_Screenshot(s *capnp.Segment) (Metadata_Screenshot, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Metadata_Screenshot(st), err
}

func ReadRootMetadata_Screenshot(msg *capnp.Message) (Metadata_Screenshot, error) {
	root, err := msg.Root()
	return Metadata_Screenshot(root.Struct()), err
}

func (s Metadata_Screenshot) String() string {
	str, _ := text.Marshal(0x8bc9f4365959348e, capnp.Struct(s))
	return str
}

func (s Metadata_Screenshot) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Metadata_Screenshot) DecodeFromPtr(p capnp.Ptr) Metadata_Screenshot {
	return Metadata_Screenshot(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Metadata_Screenshot) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Metadata_Screenshot) Which() Metadata_Screenshot_Which {
	return Metadata_Screenshot_Which(capnp.Struct(s).Uint16(8))
}
func (s Metadata_Screenshot) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Metadata_Screenshot) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Metadata_Screenshot) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Metadata_Screenshot) Width() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Metadata_Screenshot) SetWidth(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s Metadata_Screenshot) Height() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Metadata_Screenshot) SetHeight(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

func (s Metadata_Screenshot) SetUnknown() {
	capnp.Struct(s).SetUint16(8, 0)

}

func (s Metadata_Screenshot) Png() ([]byte, error) {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != png")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Metadata_Screenshot) HasPng() bool {
	if capnp.Struct(s).Uint16(8) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Metadata_Screenshot) SetPng(v []byte) error {
	capnp.Struct(s).SetUint16(8, 1)
	return capnp.Struct(s).SetData(0, v)
}

func (s Metadata_Screenshot) Jpeg() ([]byte, error) {
	if capnp.Struct(s).Uint16(8) != 2 {
		panic("Which() != jpeg")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Metadata_Screenshot) HasJpeg() bool {
	if capnp.Struct(s).Uint16(8) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Metadata_Screenshot) SetJpeg(v []byte) error {
	capnp.Struct(s).SetUint16(8, 2)
	return capnp.Struct(s).SetData(0, v)
}

// Metadata_Screenshot_List is a list of Metadata_Screenshot.
type Metadata_Screenshot_List = capnp.StructList[Metadata_Screenshot]

// NewMetadata_Screenshot creates a new list of Metadata_Screenshot.
func NewMetadata_Screenshot_List(s *capnp.Segment, sz int32) (Metadata_Screenshot_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[Metadata_Screenshot](l), err
}

// Metadata_Screenshot_Future is a wrapper for a Metadata_Screenshot promised by a client call.
type Metadata_Screenshot_Future struct{ *capnp.Future }

func (f Metadata_Screenshot_Future) Struct() (Metadata_Screenshot, error) {
	p, err := f.Future.Ptr()
	return Metadata_Screenshot(p.Struct()), err
}

type OsiLicenseInfo capnp.Struct

// OsiLicenseInfo_TypeID is the unique identifier for the type OsiLicenseInfo.
const OsiLicenseInfo_TypeID = 0xb755d258845a4a8f

func NewOsiLicenseInfo(s *capnp.Segment) (OsiLicenseInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return OsiLicenseInfo(st), err
}

func NewRootOsiLicenseInfo(s *capnp.Segment) (OsiLicenseInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return OsiLicenseInfo(st), err
}

func ReadRootOsiLicenseInfo(msg *capnp.Message) (OsiLicenseInfo, error) {
	root, err := msg.Root()
	return OsiLicenseInfo(root.Struct()), err
}

func (s OsiLicenseInfo) String() string {
	str, _ := text.Marshal(0xb755d258845a4a8f, capnp.Struct(s))
	return str
}

func (s OsiLicenseInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (OsiLicenseInfo) DecodeFromPtr(p capnp.Ptr) OsiLicenseInfo {
	return OsiLicenseInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s OsiLicenseInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s OsiLicenseInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s OsiLicenseInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s OsiLicenseInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s OsiLicenseInfo) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s OsiLicenseInfo) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s OsiLicenseInfo) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s OsiLicenseInfo) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s OsiLicenseInfo) Title() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s OsiLicenseInfo) HasTitle() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s OsiLicenseInfo) TitleBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s OsiLicenseInfo) SetTitle(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s OsiLicenseInfo) RequireSource() bool {
	return capnp.Struct(s).Bit(0)
}

func (s OsiLicenseInfo) SetRequireSource(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// OsiLicenseInfo_List is a list of OsiLicenseInfo.
type OsiLicenseInfo_List = capnp.StructList[OsiLicenseInfo]

// NewOsiLicenseInfo creates a new list of OsiLicenseInfo.
func NewOsiLicenseInfo_List(s *capnp.Segment, sz int32) (OsiLicenseInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[OsiLicenseInfo](l), err
}

// OsiLicenseInfo_Future is a wrapper for a OsiLicenseInfo promised by a client call.
type OsiLicenseInfo_Future struct{ *capnp.Future }

func (f OsiLicenseInfo_Future) Struct() (OsiLicenseInfo, error) {
	p, err := f.Future.Ptr()
	return OsiLicenseInfo(p.Struct()), err
}

type OpenSourceLicense uint16

// OpenSourceLicense_TypeID is the unique identifier for the type OpenSourceLicense.
const OpenSourceLicense_TypeID = 0xd86e43f42c8b0f74

// Values of OpenSourceLicense.
const (
	OpenSourceLicense_invalid    OpenSourceLicense = 0
	OpenSourceLicense_mit        OpenSourceLicense = 1
	OpenSourceLicense_apache2    OpenSourceLicense = 2
	OpenSourceLicense_gpl3       OpenSourceLicense = 3
	OpenSourceLicense_agpl3      OpenSourceLicense = 4
	OpenSourceLicense_bsd3Clause OpenSourceLicense = 5
	OpenSourceLicense_bsd2Clause OpenSourceLicense = 6
	OpenSourceLicense_gpl2       OpenSourceLicense = 7
	OpenSourceLicense_lgpl2      OpenSourceLicense = 8
	OpenSourceLicense_lgpl3      OpenSourceLicense = 9
	OpenSourceLicense_isc        OpenSourceLicense = 10
	OpenSourceLicense_artistic2  OpenSourceLicense = 11
	OpenSourceLicense_python2    OpenSourceLicense = 12
	OpenSourceLicense_php3       OpenSourceLicense = 13
	OpenSourceLicense_mpl2       OpenSourceLicense = 14
	OpenSourceLicense_cddl       OpenSourceLicense = 15
	OpenSourceLicense_epl        OpenSourceLicense = 16
	OpenSourceLicense_cpal       OpenSourceLicense = 17
	OpenSourceLicense_zlib       OpenSourceLicense = 18
)

// String returns the enum's constant name.
func (c OpenSourceLicense) String() string {
	switch c {
	case OpenSourceLicense_invalid:
		return "invalid"
	case OpenSourceLicense_mit:
		return "mit"
	case OpenSourceLicense_apache2:
		return "apache2"
	case OpenSourceLicense_gpl3:
		return "gpl3"
	case OpenSourceLicense_agpl3:
		return "agpl3"
	case OpenSourceLicense_bsd3Clause:
		return "bsd3Clause"
	case OpenSourceLicense_bsd2Clause:
		return "bsd2Clause"
	case OpenSourceLicense_gpl2:
		return "gpl2"
	case OpenSourceLicense_lgpl2:
		return "lgpl2"
	case OpenSourceLicense_lgpl3:
		return "lgpl3"
	case OpenSourceLicense_isc:
		return "isc"
	case OpenSourceLicense_artistic2:
		return "artistic2"
	case OpenSourceLicense_python2:
		return "python2"
	case OpenSourceLicense_php3:
		return "php3"
	case OpenSourceLicense_mpl2:
		return "mpl2"
	case OpenSourceLicense_cddl:
		return "cddl"
	case OpenSourceLicense_epl:
		return "epl"
	case OpenSourceLicense_cpal:
		return "cpal"
	case OpenSourceLicense_zlib:
		return "zlib"

	default:
		return ""
	}
}

// OpenSourceLicenseFromString returns the enum value with a name,
// or the zero value if there's no such value.
func OpenSourceLicenseFromString(c string) OpenSourceLicense {
	switch c {
	case "invalid":
		return OpenSourceLicense_invalid
	case "mit":
		return OpenSourceLicense_mit
	case "apache2":
		return OpenSourceLicense_apache2
	case "gpl3":
		return OpenSourceLicense_gpl3
	case "agpl3":
		return OpenSourceLicense_agpl3
	case "bsd3Clause":
		return OpenSourceLicense_bsd3Clause
	case "bsd2Clause":
		return OpenSourceLicense_bsd2Clause
	case "gpl2":
		return OpenSourceLicense_gpl2
	case "lgpl2":
		return OpenSourceLicense_lgpl2
	case "lgpl3":
		return OpenSourceLicense_lgpl3
	case "isc":
		return OpenSourceLicense_isc
	case "artistic2":
		return OpenSourceLicense_artistic2
	case "python2":
		return OpenSourceLicense_python2
	case "php3":
		return OpenSourceLicense_php3
	case "mpl2":
		return OpenSourceLicense_mpl2
	case "cddl":
		return OpenSourceLicense_cddl
	case "epl":
		return OpenSourceLicense_epl
	case "cpal":
		return OpenSourceLicense_cpal
	case "zlib":
		return OpenSourceLicense_zlib

	default:
		return 0
	}
}

type OpenSourceLicense_List = capnp.EnumList[OpenSourceLicense]

func NewOpenSourceLicense_List(s *capnp.Segment, sz int32) (OpenSourceLicense_List, error) {
	return capnp.NewEnumList[OpenSourceLicense](s, sz)
}

type AppId capnp.Struct

// AppId_TypeID is the unique identifier for the type AppId.
const AppId_TypeID = 0x880c6c7782a33310

func NewAppId(s *capnp.Segment) (AppId, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return AppId(st), err
}

func NewRootAppId(s *capnp.Segment) (AppId, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return AppId(st), err
}

func ReadRootAppId(msg *capnp.Message) (AppId, error) {
	root, err := msg.Root()
	return AppId(root.Struct()), err
}

func (s AppId) String() string {
	str, _ := text.Marshal(0x880c6c7782a33310, capnp.Struct(s))
	return str
}

func (s AppId) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (AppId) DecodeFromPtr(p capnp.Ptr) AppId {
	return AppId(capnp.Struct{}.DecodeFromPtr(p))
}

func (s AppId) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s AppId) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s AppId) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s AppId) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s AppId) Id0() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s AppId) SetId0(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s AppId) Id1() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s AppId) SetId1(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s AppId) Id2() uint64 {
	return capnp.Struct(s).Uint64(16)
}

func (s AppId) SetId2(v uint64) {
	capnp.Struct(s).SetUint64(16, v)
}

func (s AppId) Id3() uint64 {
	return capnp.Struct(s).Uint64(24)
}

func (s AppId) SetId3(v uint64) {
	capnp.Struct(s).SetUint64(24, v)
}

// AppId_List is a list of AppId.
type AppId_List = capnp.StructList[AppId]

// NewAppId creates a new list of AppId.
func NewAppId_List(s *capnp.Segment, sz int32) (AppId_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0}, sz)
	return capnp.StructList[AppId](l), err
}

// AppId_Future is a wrapper for a AppId promised by a client call.
type AppId_Future struct{ *capnp.Future }

func (f AppId_Future) Struct() (AppId, error) {
	p, err := f.Future.Ptr()
	return AppId(p.Struct()), err
}

type PackageId capnp.Struct

// PackageId_TypeID is the unique identifier for the type PackageId.
const PackageId_TypeID = 0xe2e344d346ffda6b

func NewPackageId(s *capnp.Segment) (PackageId, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return PackageId(st), err
}

func NewRootPackageId(s *capnp.Segment) (PackageId, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return PackageId(st), err
}

func ReadRootPackageId(msg *capnp.Message) (PackageId, error) {
	root, err := msg.Root()
	return PackageId(root.Struct()), err
}

func (s PackageId) String() string {
	str, _ := text.Marshal(0xe2e344d346ffda6b, capnp.Struct(s))
	return str
}

func (s PackageId) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (PackageId) DecodeFromPtr(p capnp.Ptr) PackageId {
	return PackageId(capnp.Struct{}.DecodeFromPtr(p))
}

func (s PackageId) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s PackageId) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s PackageId) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s PackageId) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s PackageId) Id0() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s PackageId) SetId0(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s PackageId) Id1() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s PackageId) SetId1(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

// PackageId_List is a list of PackageId.
type PackageId_List = capnp.StructList[PackageId]

// NewPackageId creates a new list of PackageId.
func NewPackageId_List(s *capnp.Segment, sz int32) (PackageId_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[PackageId](l), err
}

// PackageId_Future is a wrapper for a PackageId promised by a client call.
type PackageId_Future struct{ *capnp.Future }

func (f PackageId_Future) Struct() (PackageId, error) {
	p, err := f.Future.Ptr()
	return PackageId(p.Struct()), err
}

type VerifiedInfo capnp.Struct

// VerifiedInfo_TypeID is the unique identifier for the type VerifiedInfo.
const VerifiedInfo_TypeID = 0x987ef3040a0342a9

func NewVerifiedInfo(s *capnp.Segment) (VerifiedInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return VerifiedInfo(st), err
}

func NewRootVerifiedInfo(s *capnp.Segment) (VerifiedInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return VerifiedInfo(st), err
}

func ReadRootVerifiedInfo(msg *capnp.Message) (VerifiedInfo, error) {
	root, err := msg.Root()
	return VerifiedInfo(root.Struct()), err
}

func (s VerifiedInfo) String() string {
	str, _ := text.Marshal(0x987ef3040a0342a9, capnp.Struct(s))
	return str
}

func (s VerifiedInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VerifiedInfo) DecodeFromPtr(p capnp.Ptr) VerifiedInfo {
	return VerifiedInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VerifiedInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VerifiedInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VerifiedInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VerifiedInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VerifiedInfo) AppId() (AppId, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return AppId(p.Struct()), err
}

func (s VerifiedInfo) HasAppId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s VerifiedInfo) SetAppId(v AppId) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewAppId sets the appId field to a newly
// allocated AppId struct, preferring placement in s's segment.
func (s VerifiedInfo) NewAppId() (AppId, error) {
	ss, err := NewAppId(capnp.Struct(s).Segment())
	if err != nil {
		return AppId{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VerifiedInfo) PackageId() (PackageId, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return PackageId(p.Struct()), err
}

func (s VerifiedInfo) HasPackageId() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s VerifiedInfo) SetPackageId(v PackageId) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewPackageId sets the packageId field to a newly
// allocated PackageId struct, preferring placement in s's segment.
func (s VerifiedInfo) NewPackageId() (PackageId, error) {
	ss, err := NewPackageId(capnp.Struct(s).Segment())
	if err != nil {
		return PackageId{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VerifiedInfo) Title() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return util.LocalizedText(p.Struct()), err
}

func (s VerifiedInfo) HasTitle() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s VerifiedInfo) SetTitle(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewTitle sets the title field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s VerifiedInfo) NewTitle() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VerifiedInfo) Version() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s VerifiedInfo) SetVersion(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s VerifiedInfo) MarketingVersion() (util.LocalizedText, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return util.LocalizedText(p.Struct()), err
}

func (s VerifiedInfo) HasMarketingVersion() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s VerifiedInfo) SetMarketingVersion(v util.LocalizedText) error {
	return capnp.Struct(s).SetPtr(3, capnp.Struct(v).ToPtr())
}

// NewMarketingVersion sets the marketingVersion field to a newly
// allocated util.LocalizedText struct, preferring placement in s's segment.
func (s VerifiedInfo) NewMarketingVersion() (util.LocalizedText, error) {
	ss, err := util.NewLocalizedText(capnp.Struct(s).Segment())
	if err != nil {
		return util.LocalizedText{}, err
	}
	err = capnp.Struct(s).SetPtr(3, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VerifiedInfo) AuthorPgpKeyFingerprint() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s VerifiedInfo) HasAuthorPgpKeyFingerprint() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s VerifiedInfo) AuthorPgpKeyFingerprintBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s VerifiedInfo) SetAuthorPgpKeyFingerprint(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s VerifiedInfo) Metadata() (Metadata, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return Metadata(p.Struct()), err
}

func (s VerifiedInfo) HasMetadata() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s VerifiedInfo) SetMetadata(v Metadata) error {
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewMetadata sets the metadata field to a newly
// allocated Metadata struct, preferring placement in s's segment.
func (s VerifiedInfo) NewMetadata() (Metadata, error) {
	ss, err := NewMetadata(capnp.Struct(s).Segment())
	if err != nil {
		return Metadata{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

// VerifiedInfo_List is a list of VerifiedInfo.
type VerifiedInfo_List = capnp.StructList[VerifiedInfo]

// NewVerifiedInfo creates a new list of VerifiedInfo.
func NewVerifiedInfo_List(s *capnp.Segment, sz int32) (VerifiedInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6}, sz)
	return capnp.StructList[VerifiedInfo](l), err
}

// VerifiedInfo_Future is a wrapper for a VerifiedInfo promised by a client call.
type VerifiedInfo_Future struct{ *capnp.Future }

func (f VerifiedInfo_Future) Struct() (VerifiedInfo, error) {
	p, err := f.Future.Ptr()
	return VerifiedInfo(p.Struct()), err
}
func (p VerifiedInfo_Future) AppId() AppId_Future {
	return AppId_Future{Future: p.Future.Field(0, nil)}
}
func (p VerifiedInfo_Future) PackageId() PackageId_Future {
	return PackageId_Future{Future: p.Future.Field(1, nil)}
}
func (p VerifiedInfo_Future) Title() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(2, nil)}
}
func (p VerifiedInfo_Future) MarketingVersion() util.LocalizedText_Future {
	return util.LocalizedText_Future{Future: p.Future.Field(3, nil)}
}
func (p VerifiedInfo_Future) Metadata() Metadata_Future {
	return Metadata_Future{Future: p.Future.Field(5, nil)}
}

type CategoryInfo capnp.Struct

// CategoryInfo_TypeID is the unique identifier for the type CategoryInfo.
const CategoryInfo_TypeID = 0xb9d2951d34ca391c

func NewCategoryInfo(s *capnp.Segment) (CategoryInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return CategoryInfo(st), err
}

func NewRootCategoryInfo(s *capnp.Segment) (CategoryInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return CategoryInfo(st), err
}

func ReadRootCategoryInfo(msg *capnp.Message) (CategoryInfo, error) {
	root, err := msg.Root()
	return CategoryInfo(root.Struct()), err
}

func (s CategoryInfo) String() string {
	str, _ := text.Marshal(0xb9d2951d34ca391c, capnp.Struct(s))
	return str
}

func (s CategoryInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (CategoryInfo) DecodeFromPtr(p capnp.Ptr) CategoryInfo {
	return CategoryInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s CategoryInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s CategoryInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s CategoryInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s CategoryInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s CategoryInfo) Title() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s CategoryInfo) HasTitle() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s CategoryInfo) TitleBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s CategoryInfo) SetTitle(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// CategoryInfo_List is a list of CategoryInfo.
type CategoryInfo_List = capnp.StructList[CategoryInfo]

// NewCategoryInfo creates a new list of CategoryInfo.
func NewCategoryInfo_List(s *capnp.Segment, sz int32) (CategoryInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[CategoryInfo](l), err
}

// CategoryInfo_Future is a wrapper for a CategoryInfo promised by a client call.
type CategoryInfo_Future struct{ *capnp.Future }

func (f CategoryInfo_Future) Struct() (CategoryInfo, error) {
	p, err := f.Future.Ptr()
	return CategoryInfo(p.Struct()), err
}

type Category uint16

// Category_TypeID is the unique identifier for the type Category.
const Category_TypeID = 0x938e7e53b106e1c0

// Values of Category.
const (
	Category_productivity   Category = 1
	Category_communications Category = 2
	Category_social         Category = 3
	Category_webPublishing  Category = 4
	Category_office         Category = 5
	Category_developerTools Category = 6
	Category_science        Category = 7
	Category_graphics       Category = 10
	Category_media          Category = 8
	Category_games          Category = 9
	Category_other          Category = 0
)

// String returns the enum's constant name.
func (c Category) String() string {
	switch c {
	case Category_productivity:
		return "productivity"
	case Category_communications:
		return "communications"
	case Category_social:
		return "social"
	case Category_webPublishing:
		return "webPublishing"
	case Category_office:
		return "office"
	case Category_developerTools:
		return "developerTools"
	case Category_science:
		return "science"
	case Category_graphics:
		return "graphics"
	case Category_media:
		return "media"
	case Category_games:
		return "games"
	case Category_other:
		return "other"

	default:
		return ""
	}
}

// CategoryFromString returns the enum value with a name,
// or the zero value if there's no such value.
func CategoryFromString(c string) Category {
	switch c {
	case "productivity":
		return Category_productivity
	case "communications":
		return Category_communications
	case "social":
		return Category_social
	case "webPublishing":
		return Category_webPublishing
	case "office":
		return Category_office
	case "developerTools":
		return Category_developerTools
	case "science":
		return Category_science
	case "graphics":
		return Category_graphics
	case "media":
		return Category_media
	case "games":
		return Category_games
	case "other":
		return Category_other

	default:
		return 0
	}
}

type Category_List = capnp.EnumList[Category]

func NewCategory_List(s *capnp.Segment, sz int32) (Category_List, error) {
	return capnp.NewEnumList[Category](s, sz)
}

type KeyFile capnp.Struct

// KeyFile_TypeID is the unique identifier for the type KeyFile.
const KeyFile_TypeID = 0xe47ce2b3aab90f74

func NewKeyFile(s *capnp.Segment) (KeyFile, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return KeyFile(st), err
}

func NewRootKeyFile(s *capnp.Segment) (KeyFile, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return KeyFile(st), err
}

func ReadRootKeyFile(msg *capnp.Message) (KeyFile, error) {
	root, err := msg.Root()
	return KeyFile(root.Struct()), err
}

func (s KeyFile) String() string {
	str, _ := text.Marshal(0xe47ce2b3aab90f74, capnp.Struct(s))
	return str
}

func (s KeyFile) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (KeyFile) DecodeFromPtr(p capnp.Ptr) KeyFile {
	return KeyFile(capnp.Struct{}.DecodeFromPtr(p))
}

func (s KeyFile) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s KeyFile) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s KeyFile) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s KeyFile) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s KeyFile) PublicKey() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s KeyFile) HasPublicKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s KeyFile) SetPublicKey(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s KeyFile) PrivateKey() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s KeyFile) HasPrivateKey() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s KeyFile) SetPrivateKey(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// KeyFile_List is a list of KeyFile.
type KeyFile_List = capnp.StructList[KeyFile]

// NewKeyFile creates a new list of KeyFile.
func NewKeyFile_List(s *capnp.Segment, sz int32) (KeyFile_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[KeyFile](l), err
}

// KeyFile_Future is a wrapper for a KeyFile promised by a client call.
type KeyFile_Future struct{ *capnp.Future }

func (f KeyFile_Future) Struct() (KeyFile, error) {
	p, err := f.Future.Ptr()
	return KeyFile(p.Struct()), err
}

type Signature capnp.Struct

// Signature_TypeID is the unique identifier for the type Signature.
const Signature_TypeID = 0xeca8b9277cb36488

func NewSignature(s *capnp.Segment) (Signature, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Signature(st), err
}

func NewRootSignature(s *capnp.Segment) (Signature, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Signature(st), err
}

func ReadRootSignature(msg *capnp.Message) (Signature, error) {
	root, err := msg.Root()
	return Signature(root.Struct()), err
}

func (s Signature) String() string {
	str, _ := text.Marshal(0xeca8b9277cb36488, capnp.Struct(s))
	return str
}

func (s Signature) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Signature) DecodeFromPtr(p capnp.Ptr) Signature {
	return Signature(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Signature) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Signature) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Signature) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Signature) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Signature) PublicKey() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Signature) HasPublicKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Signature) SetPublicKey(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Signature) Signature() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Signature) HasSignature() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Signature) SetSignature(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// Signature_List is a list of Signature.
type Signature_List = capnp.StructList[Signature]

// NewSignature creates a new list of Signature.
func NewSignature_List(s *capnp.Segment, sz int32) (Signature_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Signature](l), err
}

// Signature_Future is a wrapper for a Signature promised by a client call.
type Signature_Future struct{ *capnp.Future }

func (f Signature_Future) Struct() (Signature, error) {
	p, err := f.Future.Ptr()
	return Signature(p.Struct()), err
}

type Archive capnp.Struct

// Archive_TypeID is the unique identifier for the type Archive.
const Archive_TypeID = 0xf153ba7dee1c9118

func NewArchive(s *capnp.Segment) (Archive, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Archive(st), err
}

func NewRootArchive(s *capnp.Segment) (Archive, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Archive(st), err
}

func ReadRootArchive(msg *capnp.Message) (Archive, error) {
	root, err := msg.Root()
	return Archive(root.Struct()), err
}

func (s Archive) String() string {
	str, _ := text.Marshal(0xf153ba7dee1c9118, capnp.Struct(s))
	return str
}

func (s Archive) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Archive) DecodeFromPtr(p capnp.Ptr) Archive {
	return Archive(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Archive) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Archive) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Archive) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Archive) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Archive) Files() (Archive_File_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Archive_File_List(p.List()), err
}

func (s Archive) HasFiles() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Archive) SetFiles(v Archive_File_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewFiles sets the files field to a newly
// allocated Archive_File_List, preferring placement in s's segment.
func (s Archive) NewFiles(n int32) (Archive_File_List, error) {
	l, err := NewArchive_File_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Archive_File_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Archive_List is a list of Archive.
type Archive_List = capnp.StructList[Archive]

// NewArchive creates a new list of Archive.
func NewArchive_List(s *capnp.Segment, sz int32) (Archive_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Archive](l), err
}

// Archive_Future is a wrapper for a Archive promised by a client call.
type Archive_Future struct{ *capnp.Future }

func (f Archive_Future) Struct() (Archive, error) {
	p, err := f.Future.Ptr()
	return Archive(p.Struct()), err
}

type Archive_File capnp.Struct
type Archive_File_Which uint16

const (
	Archive_File_Which_regular    Archive_File_Which = 0
	Archive_File_Which_executable Archive_File_Which = 1
	Archive_File_Which_symlink    Archive_File_Which = 2
	Archive_File_Which_directory  Archive_File_Which = 3
)

func (w Archive_File_Which) String() string {
	const s = "regularexecutablesymlinkdirectory"
	switch w {
	case Archive_File_Which_regular:
		return s[0:7]
	case Archive_File_Which_executable:
		return s[7:17]
	case Archive_File_Which_symlink:
		return s[17:24]
	case Archive_File_Which_directory:
		return s[24:33]

	}
	return "Archive_File_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Archive_File_TypeID is the unique identifier for the type Archive_File.
const Archive_File_TypeID = 0xd92313d72a1ab4d0

func NewArchive_File(s *capnp.Segment) (Archive_File, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Archive_File(st), err
}

func NewRootArchive_File(s *capnp.Segment) (Archive_File, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Archive_File(st), err
}

func ReadRootArchive_File(msg *capnp.Message) (Archive_File, error) {
	root, err := msg.Root()
	return Archive_File(root.Struct()), err
}

func (s Archive_File) String() string {
	str, _ := text.Marshal(0xd92313d72a1ab4d0, capnp.Struct(s))
	return str
}

func (s Archive_File) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Archive_File) DecodeFromPtr(p capnp.Ptr) Archive_File {
	return Archive_File(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Archive_File) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Archive_File) Which() Archive_File_Which {
	return Archive_File_Which(capnp.Struct(s).Uint16(0))
}
func (s Archive_File) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Archive_File) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Archive_File) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Archive_File) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Archive_File) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Archive_File) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Archive_File) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Archive_File) LastModificationTimeNs() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Archive_File) SetLastModificationTimeNs(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s Archive_File) Regular() ([]byte, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != regular")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Archive_File) HasRegular() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Archive_File) SetRegular(v []byte) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetData(1, v)
}

func (s Archive_File) Executable() ([]byte, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != executable")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Archive_File) HasExecutable() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Archive_File) SetExecutable(v []byte) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetData(1, v)
}

func (s Archive_File) Symlink() (string, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != symlink")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Archive_File) HasSymlink() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Archive_File) SymlinkBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Archive_File) SetSymlink(v string) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetText(1, v)
}

func (s Archive_File) Directory() (Archive_File_List, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != directory")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return Archive_File_List(p.List()), err
}

func (s Archive_File) HasDirectory() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Archive_File) SetDirectory(v Archive_File_List) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Archive_File_List, preferring placement in s's segment.
func (s Archive_File) NewDirectory(n int32) (Archive_File_List, error) {
	capnp.Struct(s).SetUint16(0, 3)
	l, err := NewArchive_File_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Archive_File_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Archive_File_List is a list of Archive_File.
type Archive_File_List = capnp.StructList[Archive_File]

// NewArchive_File creates a new list of Archive_File.
func NewArchive_File_List(s *capnp.Segment, sz int32) (Archive_File_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Archive_File](l), err
}

// Archive_File_Future is a wrapper for a Archive_File promised by a client call.
type Archive_File_Future struct{ *capnp.Future }

func (f Archive_File_Future) Struct() (Archive_File, error) {
	p, err := f.Future.Ptr()
	return Archive_File(p.Struct()), err
}

const schema_df9bc20172856a3a = "x\xda\x94Z\x0fp\x14e\x96\x7f\xaf{&\x93 a" +
	"\xd2\xf4p\xc0\x1e\xd9\x8e\x01\x14B\xc8\xc2\x0c\xb8\x10\xf0" +
	"b& \x04\x12\x9df@\x85:\xef\xec\x99\xf92\xf3" +
	"\x85\x99\xee\xb6\xa7'\x10\xcel\x16K\xf7\xc4?\xeb\x9f" +
	"U\x8f\xbd\xd5R\xd9\xb5V\xef\xd6s\xd5\xb5V)\xd9" +
	"u\xa9\xc3\x13]\xcb\xd5;N\xa1\x8e\xdaEq\xaf\xb4" +
	"\xc4+\xf6\xd8\xbb\xdd-c_}\xdd=\xdd\x9dIb" +
	"\xb8JU\xaa\xfb\xeb\xd7\xaf\xdf\xff\xf7{\xdf7+\x0e" +
	"6]\x15Z\xd9\xf8\xde:\xe0\xd2/q\xe1:\xeb\xf8" +
	"\xb7.\xb47\xfe\xfb\x91[A\x98\x15\xb2:\x07o7" +
	"\xf0\xe8\xf7~\x0d\x80\xe2;\xcd\xef\x8a\xa7\x9b#\x00\xe9" +
	"\xf7\x9byL\x9fm\xe6\x10\xc0z\xe3\xcco\xe9\xe0\xd2" +
	"\xbf\xbe\x1d\xe4Y\xc8\xf9\xf4\xe1p\x04@<\xd9|X" +
	"<\xd3\xfcu\x80D\xc3W-\x04\xb4\x9e\xfd\x8b7\xcf" +
	"=w\xfe?\xfe\x16\x84yh]\xb2\xa9c\xd9\xe6\xc3" +
	"\xef}\x08a>\x02\x90\xe8n\xe1P\xecoa\xef\xf5" +
	"\xb6<\x0bh5%\xbe\x7f\xeb\x9e\xe2\xcc;\x18\xeb\x80" +
	"(!F1\xd6rH\x0c_\xca\xae\xf0\xd2\xff\x04\xb4" +
	"\xbe\xbdj\xe7\xce+.\x1c\xbf\x0b\xe4\xb9\xc8Y\x9f]" +
	"\xd8\xbc\xbd\xed\xc0\xb1\xdf\xc0F\x8c\xf0\x18J\x9c\xb8t" +
	"6\x8a\x1f1\xf2\xc4\x99K%&H\xf8\xdd\xba\x81\x85" +
	"\xa7\xe5{@\x9e\x15\xae\x1f\xa7\xe6\xf9\xd6S\xe2Xk" +
	"D\x1ck\x95\xd2\x8b\x16\xf2\x8c\xf8\xd53u\xcf\xa5\xbf" +
	"\xf1\xed\xef\x800\x8b\x1bG;g\xe1a\xb1y!c" +
	";\x7fa\x94Q\xd2\xf7\xe7\xf0\xcb\xbb\x87\x1e\x9c\xc8\xf6" +
	"\x9e\xc5\xcf\x8b\x0f-f\xd6\xbbo\xb1\xcd\xf4\xa5\x9b\xff" +
	"g\xc1so\xbe\xf00\x93\x18}\x89\xe7\x08\x11\x04\x10" +
	"\xf7/\xfe\x1d\xa0x\xfbbf\x87\xa7\x93\xfc\x8c\xd0\x7f" +
	"\x7f\xe3 \xb3\x03\x06L\\\xc7\xd4_z\xd9)q\xf5" +
	"eL\x84\x95\x97\xdd\xcb\xf8\xde\xf0\xe6k-u\xbb\xc7" +
	"\x0eN\xce\xf7\x9d\xcb?\x01\x14O\\\xcel\xf6wo" +
	"\xd0\xadC\xd7\xee\xf9\xfb\x1a\xca\x1dB\x04C\x00\xe23" +
	"K\xfe\x04\x98xn\x89m\xafK~v \xf6\xc3\xc7" +
	"b\x8f\x810\xabV\x84\xc4[K9\x14O.e\x97" +
	"'\x96^\xcf\xa8\xef\xdd\xb2\xeb\xb6\x1b\xde\xdd\xf1\xd3Z" +
	"\x899&\xf1\xc6e\x9f\x88\xf22v\xd5\xbf\x8c\xa9\xb7" +
	"`\xed\x1b\xab\x9a\x1fz\xf7\xe5\x1a\xd6\xc8(>^v" +
	"J\xfc\xbdM{~Y\x17\xa0\xf5\xf6\xb7\x96<\xfe\xbc" +
	"\xdc\xfb\x1a\x08s\xd1\x0f=;~D\xa1\xfdObs" +
	";\xbb\x9a\xdf\xce\xf8\x9e}\xef\xb5\x9f\x8f\xb4\xeb\xc7A" +
	"\xf8s\xb4\x1e~\xb5\xb0r\xcd\xadw\x9fv\x023q" +
	"\xba\xbd\x13\xc5s\x8c8\xf1q\xbb\xad\xa0\x19\xbd\xab\xfd" +
	"B\x8f\xfa~\xad\x8f\x13B\x07\x87bs\x87\xed\xe4\x8e" +
	"\xb7\x19\xe9\xaf~\xf2\x95\xb6\xf7\xc4\x85'A\xfe3\xe4" +
	"\xacy\xf7/\xf8l\xe4p\xfa<l\xe4\"\xccl\x95" +
	"\xc4)q\x7f\x82\x91\x8f$\x1cc\xdc\x7f\xf8\xd1#\x85" +
	"#'A\x98\x1b\xf2e\x06L|\xbc*\x89\xe2\x1fW" +
	"\xb1\x98\xb8\xb0\x8a\xc7m\xab\xed\x84\xf2$\xad\xb1\x9d\xad" +
	"\xe3\xf9U\xa7\xc4\xb1UsYB\xad\xb6\xc5\xf6\xbcV" +
	"C-0\xea+\xaf8,n\xbc\xe2r\x80\xc4\x8dW" +
	"h\x1c\xa0\xb5\xfb\x94u\xf5\xbfn\xf8\xf0\x83\x9ad\xb5" +
	"3\xea\xc8\x9a\xa3\xe2\xb15\xec\xea\x17k\xf6@ ;" +
	"'qK\xf3\xda\xa3\xe2\xe2\xb5s\x01\xc4\xe5k\xbbl" +
	"\xe3\xbd\xfc\x0f/|p\xcb\xd9\x1aZ\xdb\xdd\xca\xda\xe7" +
	"E\xba\x96]\x91\xb56\xdfg\xeag\x1f<\xf4\xc0\xd9" +
	"\x9a\xa8\xdb\xc8Ex\x00\xf1\xf8\xda\x0f\xc4\x136\xf5;" +
	"k\x9f\x05\xfcb\xd7\xd7\x1f~\xe0{\xc7>\xb2i}" +
	"\x7f\xdb\xc5\xa5\xbf\xf3w\xe2\xceNf\xe8\x1d\x9d\xb6-" +
	"\xee\xc8\xbdp\xcb\xe5/?\xf5\xe9dR\xdc\xb8\xee\xa8" +
	"H\xd6\xd9\xf2\xaccRx^\x9bD\xbbc\xeb\x9e\x17" +
	"\xdfZ\xc7\xb4;\xb1\x8ei\xb7&\x9a\xf9\xa7\x1f.x" +
	"\xe4\x8f \x7f\x15=\x89v\x84#\xc8\x01$\xc2\xeb[" +
	"\x11Pl\\\xcf\xb8>v\xcd\x95W\xdc\xbc\xef\xd7c" +
	" /\xc0\x80\xa6s8\x96{\x89\x91\xf5\x1c#\xdd\xbf" +
	"~\x0fX\x81\xbf\xcb,]\xc9\xeeV\xf2\xa4\x83\xcb*" +
	"\xba\xaaw\x96\x94<\xcd^S)e\x08\x1a)Dl" +
	"\x04\x0e\x1b\x01\x04LZ\xf7\xbe\xf6\xd6\x7fm\xfc\xca'" +
	"\x0fs\xd5W\x9c7\xfa\x95.\x95\x0e\x90\xb2)\xcf\xc4" +
	"`\xc0\x09w\x062fN\xb2*\xbb tZe\xba" +
	"\x8f\xf4\xd1\x12E\xb3W\xbd^3re\x80\xd1\x1e\xad" +
	"TR\xd4\\Ww\xd6\xa4\x9a*/\xe2C\x18\x0a!" +
	"\x80p\xce\x00\x90?\xe5Q\xfe\x03\x87B\x18c\xc8\x16" +
	"\x7f\xcf\x16/\xf0\xb8\x0d9\xc4H\x8cYC\x18K\x02" +
	"\xc8\x7f\xe01\x1dC\x0e\x85z\x8c!s\xaa\x80\xb7\x02" +
	"\xa4\x9b\x90\xc7\xf4\x02\xb6\x8e\\\xcc\xae0\xf3q\x17@" +
	"z\x1e[_\xc4\xd69>\x86a\x00\xf1R<\x0a\x90" +
	"^\xc4\xd6W\xb0u\x9e\x8ba\x1d\x0b6<\x04\x90^" +
	"\xc1\xd6\xd7#\x87M|\xcc\xf6\xd7Z\xdc\x02\x90^\xc3" +
	"\x9670\xf2\xbaP\x0c\xeb\x01\xc4n{\xfd*\xb6\xde" +
	"\x87\x1cZ%\xaav\xeb\xf4:\x02\x92Q\xa6\x9a\x8a\xf5" +
	"\xc0a=\xa0UR\xf6N\xb6>\xaa\xd8f(\xe3," +
	"\xc0\x14\x8f\xd8T5\x1f [\xb2\xb2\x9ajR\xb5B" +
	"\xd05\x1b`\x93om@l\x02\xb4\x14]\xbf\x8e\x18" +
	"e\x0a|\xf0{T\xdd\xa1\xe7\x0d\x85\xcb)\x99\"\xe9" +
	"vI4\x15<\x0aE\xd7\xfb\x15c7A\x93\xaay" +
	"\xf64\xc2\xe4j\xb2z?\xf8\x9b\xaf\x1b?\xbd\xf1\xae" +
	"\x00\xfb\xed\xd4,\x12\x00\x98\xe4i\x89\x98JN1\x15" +
	"\xe7\xa9\x97i\xee\xd3j\x04\xf1N\x08\xa5\xb5\x8a\x91%" +
	"\xfd\x8a\xde\xd1\xaf\xe8:U\xf3\x90B\x94g\xf2!\x00" +
	";\x046f\x00\xe4\x0d<\xca)\xe6@7\x04\xfaw" +
	"\x01\xc8}<\xca70\xefqN\x0c\xec\xd8\x06 o" +
	"\xe7Q\xd69\xef+)\x88(f\x01g\x02\x873\x01" +
	"\xad\xb2\xfd\xb1\x94\x02|`\xb1@s$\xa5\x98\x05@" +
	"\xcf\xe4\xec\xd1\xac\x80\xac\xe8\xc8\xda\xadG\xf4\xde\x1c\x93" +
	"\xaf\xc9\x93Oi\x05\x90\xff\x92G\xb9\x10\x90\x8f\xb0\xc5" +
	"\x9bx\x94\x8b\x01\xf9([\xcc9\xf2\x09<o\x87\xa8" +
	"Pb\x8b\x05\x1ee\x93\xc3\x08\xcd\xad\xc0\x06\xe0\xb0\x01" +
	"\xd8\xf5\xca\xc0u<p\x9d\xa8^\xd7\x9a\xb2\xdf\xb5{" +
	"G:k\x10\xa2\x96\x0b\x1a\x9aL\xd8\x98'\xecH\x1c" +
	"@\xde\xcb\xa3|[@\xd8\xfd\x9d\x00\xf2-<\xcaw" +
	"p\xd8\xc8Y\x96#\xed\xed,\xa3\xbe\xc9\xa3|7\x87" +
	"\x8d\xfc\x17\x96#\xee\x01&\xeem<\xca\xf7q\xd8\x18" +
	"\x1a\xb3\xec|\x12\xeei\x03\x90\xef\xe0Q~\x90Ci" +
	"\x0f\xcd\x99\x85jDu\x15\x08\xcd\x17L/\xb4+\xea" +
	"nU\xdb\xa3B]DW\xf3n\x81\xc1\xe8\xa0N\xbc" +
	"\x9b\xda\xa2\x94UL\x92\xd7\x8c\xe1^\x95\x1f\xd0\x986" +
	"!\xe4\xac\xf3\xf7|m\xee\xec\x9b^>\x0ar\x88\xc3" +
	"\xeey\xcca \xe0a\xab\xc7%\xc6^u@\xebV" +
	"U\xad\xcbTX.\xd9\x81\xe8\xf5\xfb\x89\x8e\xedQ\xba" +
	"\x9c\x17\xd9\x07\xda\x91\xc3\x19\xc2H\\\x18\x91\x00\x84G" +
	"\x07\x85'$D\xe1\xd8>\xe1\xb8\x84\x9cp\xaeS8" +
	"'!/6\xa2!\x0a(aH\\\x8d\x9d\xe2j\x94" +
	"0,\xee\xc0}\xe2N\x94\xb0N\x1c\xc1\xa48\x82\x12" +
	"\xd6\x8b\x8fb\\|\x14%l\x10\x8f`\\<\x82\x12" +
	"F\xc4\xd3\xb8E<\x83\x92\xa4\x99\x05b\xd8\x0a\xf9\xb0" +
	"\x90)\x14c\x99\x02W\xa1\x80q\xe9ZF\x03`\xe9" +
	"\x86\x96\xabdM\x0a\xd1!j\x0eO\xf2\xd2<\xef\xa5" +
	"A+5\x8e\x18\xc0\xcaj\xa5RE\xa5Y\xe8\xb2\xed" +
	"Q\xfe\xd2\xf7\xf7Y=5\xe4\x00]e-K\x95\xe2" +
	"\x97\x0a\xdb\xd9\x95\xb6\x89\x00\xac=$\x93\xaad\x8a\x14" +
	"\xa4r\x81\xaa\xf9i>w=\xc9\xb40r\xe8\xa26" +
	"9@\x9760@\xb3d\x9a\xcf]k\x13\x01X9" +
	"2D\x8a\x9aN\xa0\xcb\xd8\xaei\xc5/Wo\x8b\xb5" +
	"\x81\x0c\xd9d\x008Z\xceR\xa2N\xf3\xa5\xe4h\xda" +
	"\xa1\x02\x90J$G\x95i|\xd6\xcfh\x00\xa4\xbcR" +
	"\"\xe5ih71\x1a\x00+o(z\x81f\xcb\x00" +
	"0\x8d\xf4\x9b<\xca\x09q\xac\x95%\xcaB\x9fu\xef" +
	"&\x1f\x0dO\xcc*\xafT(R\xc5,h\x06+\xb8" +
	"\x02\xd6\xc7\xf0\x12Vr\x07\x03%\x97k\x88\xd9\xd9\xd5" +
	"?\xe8\x97\xdc\xa6\xa6\x18\x8a\xac\xe2\xees+\xeeM\x9c" +
	"\xd3\x96\x94\xac\xb9\x11\xa2%\x85\x16\xbd\xea\xaa\xe7\xf54" +
	"\xcd\xab\x0aD\xcd\x8aA\xbc,\xaf\xe8e\xd3 J\x09" +
	"\xba\xbam\x01|\xfa\xf1\x82^G\x0c:@I\xceK" +
	"\xff\x05^1{\x91\x15\xb3\x1f\xf3(\xbf\x12(f/" +
	"\xb3&\xf0\x12\x8f\xf2?\x07*\xef/\x18\xe5+<\xca" +
	"\xafs\x88n\xe1=\xc6\xea\xdb\xab<\xca\xbf\xe4P\x08" +
	"\xf1N!;~'\x80\xfcK\x1e\xe5\xf7\x19\xde\x08\xd9" +
	"\xa8@8q\x14@~\x9fG\xf9,\xeb\xf1a\x1b\x12" +
	"\x08g\xb6\x00\xc8\xbf\xe1Q\xfe\x94CI\xd1\xf5\xde\x1c" +
	"6\xf9\x83\xe3\xf8V\xd7\x0b\xc8\x9ez \xd8y*\x99" +
	"\xac\x83Nl\x9f\xa3C\xa4\x16&\x18\xbb\x89IU\xcc" +
	"W\xfb\xf5dMW\xb1\xcd\x98\xcas\xfaV2|5" +
	"U\xf3\xc4\xd0\x0d\xaa\x9a\xe0Y\xf6\xe2\xdarm\x80\xd0" +
	"h\x96\xd5\x8b@\xc3KN\xd6\xf0\xe2\x935\xbc\xce`" +
	"\xc3\x8b\xc6p6kx\xccAE\x1e\xe5\xbd\x1c\x8e*" +
	"\xba\xbe\xc9\xa0\xcc8\x1efu\x8d\x937\x14\xaaN\\" +
	"\xefr\x8c1\xf1\x81k\xa5$\x05\xccO\xf2t*\xed" +
	"\x8a]4K\xd42a=r&k}\xcc\xe1#m" +
	"~\x97l\xc6/,t\\\xbe\x7f\x97\xdf\x11\x9b\xb91" +
	"+l\xa3@\xe1@\xc6o~\xcd\xfc\xe7l\xb9\x1e@" +
	"\xb8\x9f\xe5\xcb}<\xca\x8f\xb0\xf8\xaa\x8ba\x03\x80\xf0" +
	"]f\xbb\x07y\x94\x1f\xe70\xaaj*\x81:K\xd3" +
	"\x89\xca@\x10\xf0Y\x82Q\x7f\x1e\x04\xc4(\x93\xdc\xd0" +
	"t\x83\x12\x13\"\x8a1<\x89\xdfuVf\xb3\x1b4" +
	";\xed&\xc1j\xa3\xaaf\xd2,)O\xf6\xeax\xf8" +
	"\x90rn7\x90\x01\xaaR\xbbk\xb2|\x9b\xe79\xfe" +
	"\xbb_\xf1\x85\xf7\x1c\xff(\xcb\x83Gx\x94\x9f\x0a8" +
	"\xfeI\xe6\xe3\x1f\xf0(\xff8\x80t\x9ea\x94?\xe2" +
	"Q~\x89\x19$\xe4$\xdc\x8b\x0c\xcb\xff\x84G\xf9W" +
	",\xe1\xc2\x8e\xfd\xdf\x1a\xf4\xb3\x90\xa79?\x80\x15g" +
	"\xd8p\x0280\xd1\xda\xda\x94] \x09\xa8\xb3\x00\xa8" +
	"N\x91\xee\xd3\x01Z$}\xd4y\xb7\xcaO)\xeeQ" +
	"\x86\xcb\xbd*H\xd9b%Gj\xc1_\xc6\xa0\xb9<" +
	"\xe9\xd1 \xaa\x0eP\x16T\xde\x84<yP][\xa6" +
	"}N4E\xdd\x1a\x1c\x84\xb1\xccxW\xf1(\xf7\x05" +
	"\x8c\xd7\x1b\xf7\x0b-\x9bM8D\xa1\xdf\xf0\xebl@" +
	"y\xb7ZTE7\xc8\xcd\x15j\x904H\xb6\xd6\x88" +
	"\xc0!N\x14\xa9g\x02x\xf2\x04jd\xdf\xae\xe7Q" +
	"\x8eq\xb5\xcck\x93\xc55{GO\x973p\xb8\x9a" +
	"!\xe7h\xf6F\xa01\xb8\x8a\xed`\x19\x94r\xcb\x01" +
	"V\xcbA\xd2-\x07\xdf\xe4\xd0\xca\x11\xdd Y\xc5\xe4" +
	"Hn\xe3^\x92\xad\x98l$\xb1Q\xb8\xe7\x9f\xa8b" +
	"\xe4\x87j\x9c2J\xd4!jh\xaa7\x1bY\x8bV" +
	"=\xf7\x8fg\xf7?\xfe \xb8\xd3QMP']'" +
	"2\x17v\xa4\xb4=\xc4\xe8\xcahl\xec\xaa\x01\xc6m" +
	"\x93\x01\xe3\x8c\x9f\xf0^l\x1fh\xf3\x11\xb0\x17\xdb\xf7" +
	"\xb4\xfa5\xc0\x8b\xed\xfb3n\x05\xf8\x11Kv\xa5\xe4" +
	"\x1b8G\xcbzQ\x19\xee\x85\x88:\xa0a\x93\xf5\xe9" +
	"\xb2\x0f\x7f\xd6p(\xfd\xa4\x1bXQ=0\xb3DL" +
	"\x85\xc5^\xfc\xb3\x91\xeb\xde\xf8\xdf3\xdf\xf1b\x8f\x18" +
	"%Z.S\x88\x04&E\xac\x19[\\\x1b\\\xebV" +
	"\x98,q\xe3\xd3N\xec>[\x9d\xd3I\xc6Q8\xd1" +
	"*\x9c\x90\x90\x13\xc3\x98\x14\xc3\xc8\xf0\xed\x95\xd8&^" +
	"i\xe3\xdb\x12\xc6\xc5\x92\x8do\x9f\xc0]\xe2\x936\xbe" +
	"=\x89\xbb\xc4\xd36\x96\x15\xb86Q\xe0\x18\xd2\xed\xe6" +
	"\xe2b7\xc7\x90n\x85\x8b\x8b\x15N\xc2\x19\xe2\xd3\\" +
	"\xab\xf84'\xe1%\xe2In\x9bx\x9a\x93p\xa68" +
	"\x87O\x8asx\x09\x1b\xc5~\xbeM\xec\xe7%\x9c%" +
	"\x8e\xf0m\xe2\x08/aT|\x91o\x13_\xe4%l" +
	"\x12?\xe2[\xc5\x8fx\x09\x05q~\xa8M\x9c\x1f\x92" +
	"p\xb6\xb83\xd4&\xee\x0cI\xa3T\x1dR\x8a4\x17" +
	")Q\xd3FK\xfe\xfe'CK\x8bl\xb4\x94\xb2\x15" +
	"\x0c\xb7\x0a\xe1L\xa4\xbfw\xbb\xd5\xdf\xbb\xbd\x85\x19\x00" +
	"\"\xcc\x040\xaa\xe8J\xb6@\xe2\x93\xbc\xdf\x1e|\x7f" +
	"\x97\xd0\xf0\x80\xd5m\xd3.\x8f\x03\xdf\xb1\xc2\xbdi\xe9" +
	"C\xc7\x9a-C\x18\x07\x88\xe6\xf5b\xe2\xcbdA\x14" +
	"\xc2I!\xbcktS\xaaoy\xa2c\x85\xb5\xe9\x9a" +
	"\x1d-\x9bR}-\xc0\x0f%\x00$e\x0a\x06K\x82" +
	"\x0c\xb6\x08\x0d\x19\xab\xdb\xe5\x00\x006\x13v\x0f\x91\x16" +
	"\xc6\xc5\xca\x94s\x89\x9e\xa2R\x01\xbeL\xbe\x8c\x19\xd3" +
	"lPh\x18\xb4\x92\xe9\x0d\xcb\x13\xcb{\x8a\x10U*" +
	"e\xc2n[\xfc[\x87a\xfc\xff\xcd0>\x9ea<" +
	"\xc0\x90\xd9)~\xd1v\x8a\x8f\xb7S\x1c@*N\xc1" +
	"\xa0\xd6N\x86\xd5\xe7pXY\xb5\x13\xbb\x07\xa9e\xc8" +
	"^\xb2\xf9\\\x9c\xbd\xfbj\xec\xdd\xe7\xdb;B\xcb\xd9" +
	"\x8b\x0a\xc0\xdet\x8f\xd5\x9b\xee\x09\x06\xa0\xa5\x18&-" +
	"\x9b4\x0b8m\x10\x0e\x0a\x0d\x87\xac\xee*}\xd4\xb6" +
	"K\xf5\x16[\xdc\xb4\x8e\xb40\x03\x8d\xea\xc3fAS" +
	"/.\xaeS6\xad\x1b\xd7\xceMm\\\xeb\x05=1" +
	"\x9d\x8aI!\xbco4\xb59e\xc7ujs\xcaQ" +
	"\xb3\xcbf\x92\x00\x88\x96&wY{\x8d\xcf\xdf\x1d\xed" +
	"w}\xde\xaf\xed\xa3\xc5\xa2\xd2\xc2\xd9Sd\xb6\xaa\xa1" +
	"+R6\x97+N\x17B[\x84\x866\xabg\xc3\x86" +
	"\xbe\xe5+m\xcfE\xd95@\x84\xe8\xc5\xe9\x9c\x9e\x14" +
	"\xc2\x87G7\xa6\xec7\xad\x8d\xd9\"\xd5\xcb\xa4\x05\xab" +
	"\x92\xb8\x88\x91\x89\xa1+\x93\xf1Z5N\x8c\x95\x0d\xb3" +
	"\xd1\xeaIuW\xe5\xb0gkMmI\xf1\x0e\xbfn" +
	"\xd34h\xa6\xc2\xf0\x96\xab%2\xde\xfb\x8a43]" +
	"\xba\xb5\x09\xe1C\xd1]E\x9a\xb1\xd8\xbf\xaf\x15i\x06" +
	"u5osq#\xac\xa6\x93w\x1b\xd9\x02\x1d\"\x1d" +
	"WS\xbeHj\xc0]\x9b\x0f\xee\x9a9\xcb\xaa\xc2;" +
	"\xd6\xb3\x0f\xf2(\xff\x80\x81[\x1b\x0a\xb3O?\xc1\xa0" +
	"\xf0\xe3Nkk\x0e\x8dY\xce~\xab\xf0t\xd2\xc7}" +
	"\xcd\xe1\xcf\xd92k\x84\xcfls\x91\xdf\xebnse" +
	" \xef\xd8a\x00\xf9u\x1e\xe5\x7f\xab\xe9\x8e\xa3\x06\xc9" +
	"W\x8a\x8a\xe1\x8d\x8a\xc4\xc5\x07\xc0\x17\xbd\xf9q\xb4<" +
	"\\*Ruw\xa0\xa5\x1a$kj\x06\xe0\xb0\x8f\x0d" +
	"\xbc\x03\x13\x17\x1b\x14\x95\xb2\xd9\xaf\xe5(\x0e\xd0\xac\xbd" +
	"\xb1\xd1\xb5\x9d\x96\xc85e\x0c\x03\x87\xe1@\xe3\x0c\xd5" +
	" \x9f\xea\xa6\xb5\xb7g\xcd\x06l{\x17.\xd44\xd1" +
	"\xcc>\xe6\xe0i^\x0ea\xf0H\x083\x96\x8dB2" +
	"\xda^\x88t\xeb4\x88A\xb6\xf8\xfbp\x1e\x06\x09n" +
	"\xc3U\x81\xd4\x016\xa5\xde\xcd\xa3|\x90\xa1\x0d\xce\xb1" +
	"\xfdC\x83\xae\x03m\xcc]\xb5\xfc>\x1fs[C\x94" +
	"\xeca\xc0\xd4\x81\xcf\xe4\xb7OuoZ\xfdW\xafT" +
	"\xc7\x04E\xa7\xa9q[\xa5\xca\x10\xe9\xcd\x11\x15Mj" +
	"\x0e\xf7(z\x99\x11VQfU\x83h\xb7N\xfd}" +
	"j_M\xd7\xded\xafN\xb2f\xb7\x0e]\xfafM" +
	"\xdb]\x9e\x00S\xb1:\x8eu9\xf3\x98\\\x1f<\xbe" +
	"`\x19\xec\x9d\xaf\x0a\xe1]\xd1\xde\xac\xa6Z\xd5\xcdM" +
	"\xe05Sng\xd6\xc3\xc0\xe1\xa3\xb8\x18\xe3\xc0\x09\xee" +
	"\x94/6b\x12 ]\x8f\xd5\x93\x01\xce\xc1f\xa2`" +
	"\xaf\xcfd\xeb\xf3X\xa2\xf2\x188\x96\x14\xe7`\x128" +
	"!\x14\x89\xe1\x0c\x00a\x8c\x05\xfb\xe7U\xca0\x06\x8e" +
	"P\xc59\xd8\x09\x9cP7#f\x1f\x94x\x94\xf5\xec" +
	"[\x91Kb8\x0b@\x0cc\x06 \x1db\xdfj\xb2" +
	"O'f\xc60j\xcbv\xe7\xb8\xd3\x89\x86\xc6\x18K" +
	"nq\xbeMo\x9fN\xacb\xeb3f\xc5P\x00\x10" +
	"W\xe2\xb6\xe0)\x84D\xd9`>\xba\x87d\xca\xd4\xf4" +
	"\xb3'\xab\xe5\xc8\x0e\xc3\xdb\x7f\x19-:\xe5\xcar\xf7" +
	"Q)\xf0\xc4\xf3X\xd4?av<\xd6\xe5\xec\"X" +
	"z^\xdfJ\x86\x19\xb1\xbfKk\xe5H9kP\xdd" +
	"\x84)\x0e\x05\xca\x05\xcd07\x902\xdaTS\xedS" +
	"\x94\xab\xee\x8bhf t<?W\x0f9\x0a\x8a\x9a" +
	"'}\x9a3\xceO5\xb9r\xe3&\xd7\xde\x9c\x0dl" +
	"\xeb\xbd\x8cZ\xca`\xf9\"\x1e\xe5\x15\x81\x8cZ\xce\x16" +
	"\x97\xf0(\xaf\x9az\xc7\xbd\xf6\x03\xde!\x05\xd8\xe9\xec" +
	"\xff\x9a\x00\x93\xa3\xee\xb1Ep\xb4ba0\x93Gy" +
	"\x09\x87V\x99(F\xb6\xe0\x1e9x\xeaz\x1cj\xa6" +
	"\x167!\xb6\x12i\xf8j\xea\xd4\xe8\x80:\xdb|\xc9" +
	"=uV\xb2\x8f\xad\xe0Q^\xcfU7\x03\xb6\x12V" +
	"\x05\xbd\xfdt\x83\x0e)&\xd9\x0a<\x19\x9ej\x93\xdd" +
	"\xdb\x0f\xe9\x8dd5\xd5\x9d\xeffZ\x963\xe0%\xfd" +
	"\xd1\xb5\x11\xbf\xb0\xdc\xd9\xb5\xd5\x9f]\x1b\xb91\x0b\x03" +
	"\xa7\x90B\x7f+p\x81\xbd\xfe\xf2P\xde\x1bgt5" +
	"?\xe5\x80\xd9-\xd9'_\xdeh\x86\x813Pa\xc4" +
	"\xcek\xb7\x01\x91d\xcd~\x13+\x814\x1e\xd8o\xaa" +
	"n\xe9\x952\xfe~\x93\xc0\x87b,\x81\x85\x0a3\x9a" +
	"\xe9\x8c\xa2\x12U\xf5\x8a9\x9auf\xdb\x89giS" +
	"\xed\xd3M\x9b\x0f\xaaVQS\x05Ca\xc8y\xc2c" +
	"\xb8\x8a\x13\xc2\x0c\xce\xda\x1b]\x13\xe2\x8d\xe6U\xc5\xac" +
	"\x18\x04.&\x02\xb6M\x13\x01e\x97\x1b \x99\x10\x00" +
	"\xd5\x93-C\xb2\xa1\x81\x1d\xde^\xdb\x14\xb0-\xca\xc2" +
	"p\xb2m\x83E\x1cJ\x03\xb4H\xcaS\xb7\xdb\xda\xe3" +
	")\xcf\xcd\xb6\x97;\xa8\x1a\xd1+&\xd3\xae\x1aiK" +
	"\xdb\xfc|\xf5#m9sV;\x8f\xf2f\x7f\xd3," +
	"\xab\xe8J\x86\x16)\xf0f\xa0\xdf\xdf\xb0\xe0_~\xfe" +
	"\xfd\xe8\xdb\xe7\xa6\x12\xc0\x8b\xf2\xac\xa6v\xe8j\x1e\x1c" +
	"\xd3:!\xb54^S,XH-\x8f\xfb\x06\x97r" +
	":]\xb9\xb7jAv\x17\xf7\xee\xfe/\x00\x00\xff\xff" +
	"u\x12If"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_df9bc20172856a3a,
		Nodes: []uint64{
			0x82bdd60d2cf486c9,
			0x855f296a69e6e1ca,
			0x87dcf1b1edcb3eaf,
			0x880c6c7782a33310,
			0x8bc9f4365959348e,
			0x8d51dd236606d205,
			0x938e7e53b106e1c0,
			0x9476412d0315d869,
			0x96b3cbb11cf671b8,
			0x987ef3040a0342a9,
			0x98fd6b0620c6cb58,
			0x9a774f764b69ca97,
			0x9f149fa71489be0b,
			0xb755d258845a4a8f,
			0xb9d2951d34ca391c,
			0xc64951b2a02886cf,
			0xc9702c7dbfc6d7e4,
			0xd86e43f42c8b0f74,
			0xd92313d72a1ab4d0,
			0xd9bd68bd9dba918f,
			0xdd8c82383168c096,
			0xe0c5892a5448f4ee,
			0xe2e344d346ffda6b,
			0xe3d7ba482b2e470b,
			0xe47ce2b3aab90f74,
			0xe492a2981208ad0b,
			0xe5c59b9296375a00,
			0xeca8b9277cb36488,
			0xf153ba7dee1c9118,
			0xf99c1ca7ae620f38,
			0xfddf7a71363d4e9f,
		},
		Compressed: true,
	})
}

var x_df9bc20172856a3a = []byte{
	0, 0, 0, 0, 4, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 0,
	5, 0, 0, 0, 50, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	103, 114, 97, 105, 110, 0, 0, 0,
	0, 0, 0, 0, 4, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 0,
	5, 0, 0, 0, 50, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	103, 114, 97, 105, 110, 0, 0, 0,
}
